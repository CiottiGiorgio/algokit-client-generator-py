<?xml version='1.0' encoding='utf-8'?>
<source type="local_directory" path="../utils/algokit-utils-py/src/algokit_utils"><file name="beta/__init__.py">typing import any, noreturn def _deprecated_import_error(old_path: str, new_path: str) -&gt; noreturn: """helper create consistent deprecation error messages""" raise importerror( f"the module '{old_path}' moved v3. " f"please update imports use '{new_path}' instead. " "see migration guide details: " "https://github.com/algorandfoundation/algokit-utils-py/blob/prerelease/ts-feature-parity/docs/migration-guide.md" ) class algorandclient: """@deprecated use algokit_utils.clients.algorandclient instead""" def __init__(self, *args: any, **kwargs: any) -&gt; none: # noqa: arg002 _deprecated_import_error("algokit_utils.beta.algorandclient", "algokit_utils.algorandclient") class algokitcomposer: """@deprecated use algokit_utils.transactions.transactioncomposer instead""" def __init__(self, *args: any, **kwargs: any) -&gt; none: # noqa: arg002 _deprecated_import_error("algokit_utils.beta.algokitcomposer", "algokit_utils.transactioncomposer") class accountmanager: """@deprecated use algokit_utils.accounts.accountmanager instead""" def __init__(self, *args: any, **kwargs: any) -&gt; none: # noqa: arg002 _deprecated_import_error("algokit_utils.beta.accountmanager", "algokit_utils.accountmanager") class clientmanager: """@deprecated use algokit_utils.clients.clientmanager instead""" def __init__(self, *args: any, **kwargs: any) -&gt; none: # noqa: arg002 _deprecated_import_error("algokit_utils.beta.clientmanager", "algokit_utils.clientmanager") # re-export parameter classes deprecation warnings def __getattr__(name: str) -&gt; any: # noqa: ann401 """handle deprecated imports parameter classes""" param_mappings = { # transaction params "payparams": "algokit_utils.transactions.paymentparams", "assetcreateparams": "algokit_utils.transactions.assetcreateparams", "assetconfigparams": "algokit_utils.transactions.assetconfigparams", "assetfreezeparams": "algokit_utils.transactions.assetfreezeparams", "assetdestroyparams": "algokit_utils.transactions.assetdestroyparams", "assettransferparams": "algokit_utils.transactions.assettransferparams", "assetoptinparams": "algokit_utils.transactions.assetoptinparams", "appcallparams": "algokit_utils.transactions.appcallparams", "methodcallparams": "algokit_utils.transactions.methodcallparams", "onlinekeyregparams": "algokit_utils.transactions.onlinekeyregistrationparams", } name param_mappings: _deprecated_import_error(f"algokit_utils.beta.{name}", param_mappings[name]) raise attributeerror(f"module 'algokit_utils.beta' attribute '{name}'") # clean namespace show intended exports __all__ = [ "accountmanager", "algokitcomposer", "algorandclient", "clientmanager", ]</file><file name="clients/dispenser_api_client.py">import contextlib import enum import os dataclasses import dataclass import httpx algokit_utils.config import config __all__ = [ "dispenser_access_token_key", "dispenser_assets", "dispenser_request_timeout", "dispenserapiconfig", "dispenserasset", "dispenserassetname", "dispenserfundresponse", "dispenserlimitresponse", "testnetdispenserapiclient", ] logger = config.logger class dispenserapiconfig: base_url = "https://api.dispenser.algorandfoundation.tools" class dispenserassetname(enum.intenum): algo = 0 @dataclass class dispenserasset: asset_id: int decimals: int description: str @dataclass class dispenserfundresponse: tx_id: str amount: int @dataclass class dispenserlimitresponse: amount: int dispenser_assets = { dispenserassetname.algo: dispenserasset( asset_id=0, decimals=6, description="algo", ), } dispenser_request_timeout = 15 dispenser_access_token_key = "algokit_dispenser_access_token" class testnetdispenserapiclient: """ client interacting [algokit testnet dispenser api](https://github.com/algorandfoundation/algokit/blob/main/docs/testnet_api.md). get started create new access token via `algokit dispenser login --ci` pass client constructor `auth_token`. alternatively set access token environment variable `algokit_dispenser_access_token`, auto loaded. set, constructor argument takes precedence. default request timeout 15 seconds. modify passing `request_timeout` constructor. """ auth_token: str request_timeout = dispenser_request_timeout def __init__(self, auth_token: str | none = none, request_timeout: int = dispenser_request_timeout): auth_token_from_env = os.getenv(dispenser_access_token_key) auth_token: self.auth_token = auth_token elif auth_token_from_env: self.auth_token = auth_token_from_env else: raise exception( f"can't init algokit testnet dispenser api client " f"because neither environment variable {dispenser_access_token_key} " "the auth_token provided." ) self.request_timeout = request_timeout def _process_dispenser_request( self, *, auth_token: str, url_suffix: str, data: dict | none = none, method: str = "post" ) -&gt; httpx.response: """ generalized method process http requests dispenser api """ headers = {"authorization": f"bearer {(auth_token)}"} # set request arguments request_args = { "url": f"{dispenserapiconfig.base_url}/{url_suffix}", "headers": headers, "timeout": self.request_timeout, } method.upper() != "get" data none: request_args["json"] = data try: response: httpx.response = getattr(httpx, method.lower())(**request_args) response.raise_for_status() return response except httpx.httpstatuserror err: error_message = f"error processing dispenser api request: {err.response.status_code}" error_response = none contextlib.suppress(exception): error_response = err.response.json() error_response error_response.get("code"): error_message = error_response.get("code") elif err.response.status_code == httpx.codes.bad_request: error_message = err.response.json()["message"] raise exception(error_message) err except exception err: error_message = "error processing dispenser api request" logger.debug(f"{error_message}: {err}", exc_info=true) raise err def fund(self, address: str, amount: int, asset_id: int) -&gt; dispenserfundresponse: """ fund account algos dispenser api """ try: response = self._process_dispenser_request( auth_token=self.auth_token, url_suffix=f"fund/{asset_id}", data={"receiver": address, "amount": amount, "assetid": asset_id}, method="post", ) content = response.json() return dispenserfundresponse(tx_id=content["txid"], amount=content["amount"]) except exception err: logger.exception(f"error funding account {address}: {err}") raise err def refund(self, refund_txn_id: str) -&gt; none: """ register refund transaction dispenser api """ try: self._process_dispenser_request( auth_token=self.auth_token, url_suffix="refund", data={"refundtransactionid": refund_txn_id}, method="post", ) except exception err: logger.exception(f"error issuing refund txn_id {refund_txn_id}: {err}") raise err def get_limit( self, address: str, ) -&gt; dispenserlimitresponse: """ get current limit account algos dispenser api """ try: response = self._process_dispenser_request( auth_token=self.auth_token, url_suffix=f"fund/{dispenser_assets[dispenserassetname.algo].asset_id}/limit", method="get", ) content = response.json() return dispenserlimitresponse(amount=content["amount"]) except exception err: logger.exception(f"error setting limit account {address}: {err}") raise err</file><file name="clients/algorand_client.py">import copy import time import typing_extensions algosdk.atomic_transaction_composer import transactionsigner algosdk.kmd import kmdclient algosdk.transaction import suggestedparams algosdk.v2client.algod import algodclient algosdk.v2client.indexer import indexerclient algokit_utils.accounts.account_manager import accountmanager algokit_utils.applications.app_deployer import appdeployer algokit_utils.applications.app_manager import appmanager algokit_utils.assets.asset_manager import assetmanager algokit_utils.clients.client_manager import algosdkclients, clientmanager algokit_utils.models.network import algoclientconfig, algoclientconfigs algokit_utils.transactions.transaction_composer import ( transactioncomposer, ) algokit_utils.transactions.transaction_creator import algorandclienttransactioncreator algokit_utils.transactions.transaction_sender import algorandclienttransactionsender __all__ = [ "algorandclient", ] class algorandclient: """a client brokers easy access algorand functionality.""" def __init__(self, config: algoclientconfigs | algosdkclients): self._client_manager: clientmanager = clientmanager(clients_or_configs=config, algorand_client=self) self._account_manager: accountmanager = accountmanager(self._client_manager) self._asset_manager: assetmanager = assetmanager(self._client_manager.algod, lambda: self.new_group()) self._app_manager: appmanager = appmanager(self._client_manager.algod) self._transaction_sender = algorandclienttransactionsender( new_group=lambda: self.new_group(), asset_manager=self._asset_manager, app_manager=self._app_manager, algod_client=self._client_manager.algod, ) self._app_deployer: appdeployer = appdeployer( self._app_manager, self._transaction_sender, self._client_manager.indexer_if_present ) self._transaction_creator = algorandclienttransactioncreator( new_group=lambda: self.new_group(), ) self._cached_suggested_params: suggestedparams | none = none self._cached_suggested_params_expiry: float | none = none self._cached_suggested_params_timeout: int = 3_000 # three seconds self._default_validity_window: int = 10 def set_default_validity_window(self, validity_window: int) -&gt; typing_extensions.self: """ sets default validity window transactions. :param validity_window: number rounds first last valid rounds :return: `algorandclient` method calls chained """ self._default_validity_window = validity_window return self def set_default_signer(self, signer: transactionsigner) -&gt; typing_extensions.self: """ sets default signer use signer specified. :param signer: signer use, either `transactionsigner` `transactionsigneraccount` :return: `algorandclient` method calls chained """ self._account_manager.set_default_signer(signer) return self def set_signer(self, sender: str, signer: transactionsigner) -&gt; typing_extensions.self: """ tracks given account later signing. :param sender: sender address use signer :param signer: signer sign transactions given sender :return: `algorandclient` method calls chained """ self._account_manager.set_signer(sender, signer) return self def set_suggested_params( self, suggested_params: suggestedparams, until: float | none = none ) -&gt; typing_extensions.self: """ sets cache value use suggested params. :param suggested_params: suggested params use :param until: timestamp cache, specified timeout used :return: `algorandclient` method calls chained """ self._cached_suggested_params = suggested_params self._cached_suggested_params_expiry = time.time() + self._cached_suggested_params_timeout return self def set_suggested_params_timeout(self, timeout: int) -&gt; typing_extensions.self: """ sets timeout caching suggested params. :param timeout: timeout milliseconds :return: `algorandclient` method calls chained """ self._cached_suggested_params_timeout = timeout return self def get_suggested_params(self) -&gt; suggestedparams: """get suggested params transaction (either cached algod cache stale empty)""" self._cached_suggested_params ( self._cached_suggested_params_expiry none self._cached_suggested_params_expiry &gt; time.time() ): return copy.deepcopy(self._cached_suggested_params) self._cached_suggested_params = self._client_manager.algod.suggested_params() self._cached_suggested_params_expiry = time.time() + self._cached_suggested_params_timeout return copy.deepcopy(self._cached_suggested_params) def new_group(self) -&gt; transactioncomposer: """start new `transactioncomposer` transaction group""" return transactioncomposer( algod=self.client.algod, get_signer=lambda addr: self.account.get_signer(addr), get_suggested_params=self.get_suggested_params, default_validity_window=self._default_validity_window, ) @property def client(self) -&gt; clientmanager: """get clients, including algosdk clients app clients.""" return self._client_manager @property def account(self) -&gt; accountmanager: """get create accounts sign transactions.""" return self._account_manager @property def asset(self) -&gt; assetmanager: """get create assets.""" return self._asset_manager @property def app(self) -&gt; appmanager: return self._app_manager @property def app_deployer(self) -&gt; appdeployer: """get create applications.""" return self._app_deployer @property def send(self) -&gt; algorandclienttransactionsender: """methods sending transaction waiting confirmation""" return self._transaction_sender @property def create_transaction(self) -&gt; algorandclienttransactioncreator: """methods building transactions""" return self._transaction_creator @staticmethod def default_localnet() -&gt; "algorandclient": """ returns `algorandclient` pointing default localnet ports api token. :return: `algorandclient` """ return algorandclient( algoclientconfigs( algod_config=clientmanager.get_default_localnet_config("algod"), indexer_config=clientmanager.get_default_localnet_config("indexer"), kmd_config=clientmanager.get_default_localnet_config("kmd"), ) ) @staticmethod def testnet() -&gt; "algorandclient": """ returns `algorandclient` pointing testnet using algonode. :return: `algorandclient` """ return algorandclient( algoclientconfigs( algod_config=clientmanager.get_algonode_config("testnet", "algod"), indexer_config=clientmanager.get_algonode_config("testnet", "indexer"), kmd_config=none, ) ) @staticmethod def mainnet() -&gt; "algorandclient": """ returns `algorandclient` pointing mainnet using algonode. :return: `algorandclient` """ return algorandclient( algoclientconfigs( algod_config=clientmanager.get_algonode_config("mainnet", "algod"), indexer_config=clientmanager.get_algonode_config("mainnet", "indexer"), kmd_config=none, ) ) @staticmethod def from_clients( algod: algodclient, indexer: indexerclient | none = none, kmd: kmdclient | none = none ) -&gt; "algorandclient": """ returns `algorandclient` pointing given client(s). :param algod: algod client use :param indexer: indexer client use :param kmd: kmd client use :return: `algorandclient` """ return algorandclient(algosdkclients(algod=algod, indexer=indexer, kmd=kmd)) @staticmethod def from_environment() -&gt; "algorandclient": """ returns `algorandclient` loading configuration environment variables. retrieve configurations environment variables defined get defaults. expects called python environment. :return: `algorandclient` """ return algorandclient(clientmanager.get_config_from_environment_or_localnet()) @staticmethod def from_config( algod_config: algoclientconfig, indexer_config: algoclientconfig | none = none, kmd_config: algoclientconfig | none = none, ) -&gt; "algorandclient": """ returns `algorandclient` given config. :param algod_config: config use algod client :param indexer_config: config use indexer client :param kmd_config: config use kmd client :return: `algorandclient` """ return algorandclient( algoclientconfigs(algod_config=algod_config, indexer_config=indexer_config, kmd_config=kmd_config) )</file><file name="clients/__init__.py">algokit_utils.clients.algorand_client import * # noqa: f403 algokit_utils.clients.client_manager import * # noqa: f403 algokit_utils.clients.dispenser_api_client import * # noqa: f403</file><file name="clients/client_manager.py">import os dataclasses import dataclass typing import literal urllib import parse import algosdk algosdk.atomic_transaction_composer import transactionsigner algosdk.kmd import kmdclient algosdk.source_map import sourcemap algosdk.v2client.algod import algodclient algosdk.v2client.indexer import indexerclient # algokit_utils.applications.app_factory import appfactory, appfactoryparams algokit_utils._legacy_v2.application_specification import applicationspecification algokit_utils.applications.app_client import appclient, appclientparams algokit_utils.applications.app_deployer import applookup algokit_utils.applications.app_factory import appfactory, appfactoryparams algokit_utils.applications.app_spec.arc56 import arc56contract algokit_utils.clients.dispenser_api_client import testnetdispenserapiclient algokit_utils.models.network import algoclientconfig, algoclientconfigs algokit_utils.models.state import tealtemplateparams algokit_utils.protocols.client import algorandclientprotocol __all__ = [ "algosdkclients", "clientmanager", "networkdetail", ] class algosdkclients: def __init__( self, algod: algosdk.v2client.algod.algodclient, indexer: indexerclient | none = none, kmd: kmdclient | none = none, ): self.algod = algod self.indexer = indexer self.kmd = kmd @dataclass(kw_only=true, frozen=true) class networkdetail: is_testnet: bool is_mainnet: bool is_localnet: bool genesis_id: str genesis_hash: str def _get_config_from_environment(environment_prefix: str) -&gt; algoclientconfig: server = os.getenv(f"{environment_prefix}_server") server none: raise exception(f"server environment variable set: {environment_prefix}_server") port = os.getenv(f"{environment_prefix}_port") port: parsed = parse.urlparse(server) server = parsed._replace(netloc=f"{parsed.hostname}:{port}").geturl() return algoclientconfig(server, os.getenv(f"{environment_prefix}_token", "")) class clientmanager: def __init__(self, clients_or_configs: algoclientconfigs | algosdkclients, algorand_client: algorandclientprotocol): isinstance(clients_or_configs, algosdkclients): _clients = clients_or_configs elif isinstance(clients_or_configs, algoclientconfigs): _clients = algosdkclients( algod=clientmanager.get_algod_client(clients_or_configs.algod_config), indexer=clientmanager.get_indexer_client(clients_or_configs.indexer_config) clients_or_configs.indexer_config else none, kmd=clientmanager.get_kmd_client(clients_or_configs.kmd_config) clients_or_configs.kmd_config else none, ) self._algod = _clients.algod self._indexer = _clients.indexer self._kmd = _clients.kmd self._algorand = algorand_client @property def algod(self) -&gt; algodclient: """returns algosdk algod api client.""" return self._algod @property def indexer(self) -&gt; indexerclient: """returns algosdk indexer api client raises error provided.""" self._indexer: raise valueerror("attempt use indexer client algokit instance indexer configured") return self._indexer @property def indexer_if_present(self) -&gt; indexerclient | none: return self._indexer @property def kmd(self) -&gt; kmdclient: """returns algosdk kmd api client raises error provided.""" self._kmd: raise valueerror("attempt use kmd client algokit instance kmd configured") return self._kmd def network(self) -&gt; networkdetail: sp = self._algod.suggested_params() # todo: cache return networkdetail( is_testnet=sp.gen ["testnet-v1.0", "testnet-v1", "testnet"], is_mainnet=sp.gen ["mainnet-v1.0", "mainnet-v1", "mainnet"], is_localnet=clientmanager.genesis_id_is_localnet(str(sp.gen)), genesis_id=str(sp.gen), genesis_hash=sp.gh, ) def is_localnet(self) -&gt; bool: return self.network().is_localnet def is_testnet(self) -&gt; bool: return self.network().is_testnet def is_mainnet(self) -&gt; bool: return self.network().is_mainnet def get_testnet_dispenser( self, auth_token: str | none = none, request_timeout: int | none = none ) -&gt; testnetdispenserapiclient: request_timeout: return testnetdispenserapiclient(auth_token=auth_token, request_timeout=request_timeout) return testnetdispenserapiclient(auth_token=auth_token) def get_app_factory( self, app_spec: arc56contract | applicationspecification | str, app_name: str | none = none, default_sender: str | none = none, default_signer: transactionsigner | none = none, version: str | none = none, updatable: bool | none = none, deletable: bool | none = none, deploy_time_params: tealtemplateparams | none = none, ) -&gt; appfactory: self._algorand: raise valueerror("attempt get app factory clientmanager without algorand client") return appfactory( appfactoryparams( algorand=self._algorand, app_spec=app_spec, app_name=app_name, default_sender=default_sender, default_signer=default_signer, version=version, updatable=updatable, deletable=deletable, deploy_time_params=deploy_time_params, ) ) def get_app_client_by_id( self, app_spec: (arc56contract | applicationspecification | str), app_id: int, app_name: str | none = none, default_sender: str | bytes | none = none, default_signer: transactionsigner | none = none, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, ) -&gt; appclient: self._algorand: raise valueerror("attempt get app client clientmanager without algorand client") return appclient( appclientparams( app_spec=app_spec, algorand=self._algorand, app_id=app_id, app_name=app_name, default_sender=default_sender, default_signer=default_signer, approval_source_map=approval_source_map, clear_source_map=clear_source_map, ) ) def get_app_client_by_network( self, app_spec: (arc56contract | applicationspecification | str), app_name: str | none = none, default_sender: str | bytes | none = none, default_signer: transactionsigner | none = none, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, ) -&gt; appclient: self._algorand: raise valueerror("attempt get app client clientmanager without algorand client") return appclient.from_network( app_spec=app_spec, app_name=app_name, default_sender=default_sender, default_signer=default_signer, approval_source_map=approval_source_map, clear_source_map=clear_source_map, algorand=self._algorand, ) def get_app_client_by_creator_and_name( self, creator_address: str, app_name: str, app_spec: arc56contract | applicationspecification | str, default_sender: str | bytes | none = none, default_signer: transactionsigner | none = none, ignore_cache: bool | none = none, app_lookup_cache: applookup | none = none, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, ) -&gt; appclient: return appclient.from_creator_and_name( creator_address=creator_address, app_name=app_name, default_sender=default_sender, default_signer=default_signer, ignore_cache=ignore_cache, app_lookup_cache=app_lookup_cache, app_spec=app_spec, approval_source_map=approval_source_map, clear_source_map=clear_source_map, algorand=self._algorand, ) @staticmethod def get_algod_client(config: algoclientconfig | none = none) -&gt; algodclient: """returns {py:class}`algosdk.v2client.algod.algodclient` `config` environment configuration provided use environment variables `algod_server`, `algod_port` `algod_token`""" config = config _get_config_from_environment("algod") headers = {"x-algo-api-token": config.token ""} return algodclient(algod_token=config.token "", algod_address=config.server, headers=headers) @staticmethod def get_algod_client_from_environment() -&gt; algodclient: return clientmanager.get_algod_client(clientmanager.get_algod_config_from_environment()) @staticmethod def get_kmd_client(config: algoclientconfig | none = none) -&gt; kmdclient: """returns {py:class}`algosdk.kmd.kmdclient` `config` environment configuration provided use environment variables `kmd_server`, `kmd_port` `kmd_token`""" config = config _get_config_from_environment("kmd") return kmdclient(config.token, config.server) @staticmethod def get_kmd_client_from_environment() -&gt; kmdclient: return clientmanager.get_kmd_client(clientmanager.get_kmd_config_from_environment()) @staticmethod def get_indexer_client(config: algoclientconfig | none = none) -&gt; indexerclient: """returns {py:class}`algosdk.v2client.indexer.indexerclient` `config` environment. configuration provided use environment variables `indexer_server`, `indexer_port` `indexer_token`""" config = config _get_config_from_environment("indexer") headers = {"x-indexer-api-token": config.token} return indexerclient(indexer_token=config.token, indexer_address=config.server, headers=headers) @staticmethod def get_indexer_client_from_environment() -&gt; indexerclient: return clientmanager.get_indexer_client(clientmanager.get_indexer_config_from_environment()) @staticmethod def genesis_id_is_localnet(genesis_id: str) -&gt; bool: return genesis_id ["devnet-v1", "sandnet-v1", "dockernet-v1"] @staticmethod def get_config_from_environment_or_localnet() -&gt; algoclientconfigs: """retrieve client configuration environment variables fallback localnet defaults. algod_server set environment variables, use environment configuration, otherwise use default localnet configuration. returns: algoclientconfigs: configuration algod, indexer, optionally kmd """ algod_server = os.getenv("algod_server") algod_server: # use environment configuration algod_config = clientmanager.get_algod_config_from_environment() # include indexer indexer_server set indexer_config = ( clientmanager.get_indexer_config_from_environment() os.getenv("indexer_server") else none ) # include kmd config local networks (not mainnet/testnet) kmd_config = ( algoclientconfig( server=algod_config.server, token=algod_config.token, port=os.getenv("kmd_port", "4002") ) any(net algod_server.lower() net ["mainnet", "testnet"]) else none ) else: # use localnet defaults algod_config = clientmanager.get_default_localnet_config("algod") indexer_config = clientmanager.get_default_localnet_config("indexer") kmd_config = clientmanager.get_default_localnet_config("kmd") return algoclientconfigs( algod_config=algod_config, indexer_config=indexer_config, kmd_config=kmd_config, ) @staticmethod def get_default_localnet_config(config_or_port: literal["algod", "indexer", "kmd"] | int) -&gt; algoclientconfig: port = ( config_or_port isinstance(config_or_port, int) else {"algod": 4001, "indexer": 8980, "kmd": 4002}[config_or_port] ) return algoclientconfig(server=f"http://localhost:{port}", token="a" * 64) @staticmethod def get_algod_config_from_environment() -&gt; algoclientconfig: """retrieve algod configuration environment variables. expects algod_server defined environment variables. algod_port algod_token optional. raises: valueerror: algod_server environment variable set """ return _get_config_from_environment("algod") @staticmethod def get_indexer_config_from_environment() -&gt; algoclientconfig: """retrieve indexer configuration environment variables. expects indexer_server defined environment variables. indexer_port indexer_token optional. raises: valueerror: indexer_server environment variable set """ return _get_config_from_environment("indexer") @staticmethod def get_kmd_config_from_environment() -&gt; algoclientconfig: """retrieve kmd configuration environment variables. expects kmd_server defined environment variables. kmd_port kmd_token optional. """ return _get_config_from_environment("kmd") @staticmethod def get_algonode_config( network: literal["testnet", "mainnet"], config: literal["algod", "indexer"] ) -&gt; algoclientconfig: """returns algorand configuration point free tier algonode service. args: network: network connect - testnet mainnet config: algod config return - algod indexer returns: algoclientconfig: configuration specified network service """ service_type = "api" config == "algod" else "idx" return algoclientconfig( server=f"https://{network}-{service_type}.algonode.cloud", port=443, )</file><file name="models/amount.py">__future__ import annotations decimal import decimal import algosdk typing_extensions import self __all__ = ["algoamount"] class algoamount: """wrapper class ensure safe, explicit conversion algo, algo numbers.""" def __init__(self, amount: dict[str, int | decimal]): """create new algoamount instance. :param amount: dictionary containing either algos, algo, microalgos, microalgo key corresponding value integer decimal. :raises valueerror: invalid amount format provided. :example: &gt;&gt;&gt; amount = algoamount({"algos": 1}) &gt;&gt;&gt; amount = algoamount({"microalgos": 1_000_000}) """ "microalgos" amount: self.amount_in_micro_algo = int(amount["microalgos"]) elif "microalgo" amount: self.amount_in_micro_algo = int(amount["microalgo"]) elif "algos" amount: self.amount_in_micro_algo = algosdk.util.algos_to_microalgos(float(amount["algos"])) elif "algo" amount: self.amount_in_micro_algo = algosdk.util.algos_to_microalgos(float(amount["algo"])) else: raise valueerror("invalid amount provided") @property def micro_algos(self) -&gt; int: """return amount number algo. :returns: amount algo. """ return self.amount_in_micro_algo @property def micro_algo(self) -&gt; int: """return amount number algo. :returns: amount algo. """ return self.amount_in_micro_algo @property def algos(self) -&gt; int | decimal: """return amount number algo. :returns: amount algo. """ return algosdk.util.microalgos_to_algos(self.amount_in_micro_algo) # type: ignore[no-any-return] @property def algo(self) -&gt; int | decimal: """return amount number algo. :returns: amount algo. """ return algosdk.util.microalgos_to_algos(self.amount_in_micro_algo) # type: ignore[no-any-return] @staticmethod def from_algos(amount: int | decimal) -&gt; algoamount: """create algoamount object representing given number algo. :param amount: amount algo. :returns: algoamount instance. :example: &gt;&gt;&gt; amount = algoamount.from_algos(1) """ return algoamount({"algos": amount}) @staticmethod def from_algo(amount: int | decimal) -&gt; algoamount: """create algoamount object representing given number algo. :param amount: amount algo. :returns: algoamount instance. :example: &gt;&gt;&gt; amount = algoamount.from_algo(1) """ return algoamount({"algo": amount}) @staticmethod def from_micro_algos(amount: int | decimal) -&gt; algoamount: """create algoamount object representing given number algo. :param amount: amount algo. :returns: algoamount instance. :example: &gt;&gt;&gt; amount = algoamount.from_micro_algos(1_000_000) """ return algoamount({"microalgos": amount}) @staticmethod def from_micro_algo(amount: int | decimal) -&gt; algoamount: """create algoamount object representing given number algo. :param amount: amount algo. :returns: algoamount instance. :example: &gt;&gt;&gt; amount = algoamount.from_micro_algo(1_000_000) """ return algoamount({"microalgo": amount}) def __str__(self) -&gt; str: return f"{self.micro_algo:,} algo" def __int__(self) -&gt; int: return self.micro_algos def __add__(self, other: int | decimal | algoamount) -&gt; algoamount: isinstance(other, algoamount): total_micro_algos = self.micro_algos + other.micro_algos elif isinstance(other, (int | decimal)): total_micro_algos = self.micro_algos + int(other) else: raise typeerror(f"unsupported operand type(s) +: 'algoamount' '{type(other).__name__}'") return algoamount.from_micro_algos(total_micro_algos) def __radd__(self, other: int | decimal) -&gt; algoamount: return self.__add__(other) def __iadd__(self, other: int | decimal | algoamount) -&gt; self: isinstance(other, algoamount): self.amount_in_micro_algo += other.micro_algos elif isinstance(other, (int | decimal)): self.amount_in_micro_algo += int(other) else: raise typeerror(f"unsupported operand type(s) +: 'algoamount' '{type(other).__name__}'") return self def __eq__(self, other: object) -&gt; bool: isinstance(other, algoamount): return self.amount_in_micro_algo == other.amount_in_micro_algo elif isinstance(other, int | decimal): return self.amount_in_micro_algo == int(other) raise typeerror(f"unsupported operand type(s) ==: 'algoamount' '{type(other).__name__}'") def __ne__(self, other: object) -&gt; bool: isinstance(other, algoamount): return self.amount_in_micro_algo != other.amount_in_micro_algo elif isinstance(other, int | decimal): return self.amount_in_micro_algo != int(other) raise typeerror(f"unsupported operand type(s) !=: 'algoamount' '{type(other).__name__}'") def __lt__(self, other: object) -&gt; bool: isinstance(other, algoamount): return self.amount_in_micro_algo &lt; other.amount_in_micro_algo elif isinstance(other, int | decimal): return self.amount_in_micro_algo &lt; int(other) raise typeerror(f"unsupported operand type(s) &lt;: 'algoamount' '{type(other).__name__}'") def __le__(self, other: object) -&gt; bool: isinstance(other, algoamount): return self.amount_in_micro_algo &lt;= other.amount_in_micro_algo elif isinstance(other, int | decimal): return self.amount_in_micro_algo &lt;= int(other) raise typeerror(f"unsupported operand type(s) &lt;=: 'algoamount' '{type(other).__name__}'") def __gt__(self, other: object) -&gt; bool: isinstance(other, algoamount): return self.amount_in_micro_algo &gt; other.amount_in_micro_algo elif isinstance(other, int | decimal): return self.amount_in_micro_algo &gt; int(other) raise typeerror(f"unsupported operand type(s) &gt;: 'algoamount' '{type(other).__name__}'") def __ge__(self, other: object) -&gt; bool: isinstance(other, algoamount): return self.amount_in_micro_algo &gt;= other.amount_in_micro_algo elif isinstance(other, int | decimal): return self.amount_in_micro_algo &gt;= int(other) raise typeerror(f"unsupported operand type(s) &gt;=: 'algoamount' '{type(other).__name__}'") def __sub__(self, other: int | decimal | algoamount) -&gt; algoamount: isinstance(other, algoamount): total_micro_algos = self.micro_algos - other.micro_algos elif isinstance(other, (int | decimal)): total_micro_algos = self.micro_algos - int(other) else: raise typeerror(f"unsupported operand type(s) -: 'algoamount' '{type(other).__name__}'") return algoamount.from_micro_algos(total_micro_algos) def __rsub__(self, other: int | decimal) -&gt; algoamount: isinstance(other, (int | decimal)): total_micro_algos = int(other) - self.micro_algos return algoamount.from_micro_algos(total_micro_algos) raise typeerror(f"unsupported operand type(s) -: '{type(other).__name__}' 'algoamount'") def __isub__(self, other: int | decimal | algoamount) -&gt; self: isinstance(other, algoamount): self.amount_in_micro_algo -= other.micro_algos elif isinstance(other, (int | decimal)): self.amount_in_micro_algo -= int(other) else: raise typeerror(f"unsupported operand type(s) -: 'algoamount' '{type(other).__name__}'") return self</file><file name="models/transaction.py">dataclasses import dataclass typing import any, literal, typeddict, typevar import algosdk __all__ = [ "arc2transactionnote", "basearc2note", "jsonformatarc2note", "stringformatarc2note", "transactionnote", "transactionnotedata", "transactionwrapper", ] # define specific types different formats class basearc2note(typeddict): """base arc-0002 transaction note structure""" dapp_name: str class stringformatarc2note(basearc2note): """arc-0002 note string-based formats (m/b/u)""" format: literal["m", "b", "u"] data: str class jsonformatarc2note(basearc2note): """arc-0002 note json format""" format: literal["j"] data: str | dict[str, any] | list[any] | int | none # combined type valid arc-0002 notes # see: https://github.com/algorandfoundation/arcs/blob/main/arcs/arc-0002.md arc2transactionnote = stringformatarc2note | jsonformatarc2note transactionnotedata = str | none | int | list[any] | dict[str, any] transactionnote = bytes | transactionnotedata | arc2transactionnote txntypet = typevar("txntypet", bound=algosdk.transaction.transaction) class transactionwrapper(algosdk.transaction.transaction): """wrapper around algosdk.transaction.transaction optional property validators""" def __init__(self, transaction: algosdk.transaction.transaction) -&gt; none: self._raw = transaction @property def raw(self) -&gt; algosdk.transaction.transaction: return self._raw @property def payment(self) -&gt; algosdk.transaction.paymenttxn: return self._return_if_type( algosdk.transaction.paymenttxn, ) @property def keyreg(self) -&gt; algosdk.transaction.keyregtxn: return self._return_if_type(algosdk.transaction.keyregtxn) @property def asset_config(self) -&gt; algosdk.transaction.assetconfigtxn: return self._return_if_type(algosdk.transaction.assetconfigtxn) @property def asset_transfer(self) -&gt; algosdk.transaction.assettransfertxn: return self._return_if_type(algosdk.transaction.assettransfertxn) @property def asset_freeze(self) -&gt; algosdk.transaction.assetfreezetxn: return self._return_if_type(algosdk.transaction.assetfreezetxn) @property def application_call(self) -&gt; algosdk.transaction.applicationcalltxn: return self._return_if_type(algosdk.transaction.applicationcalltxn) @property def state_proof(self) -&gt; algosdk.transaction.stateprooftxn: return self._return_if_type(algosdk.transaction.stateprooftxn) def _return_if_type(self, txn_type: type[txntypet]) -&gt; txntypet: isinstance(self._raw, txn_type): return self._raw raise valueerror(f"transaction type {txn_type.__name__}") @dataclass(kw_only=true, frozen=true) class sendparams: max_rounds_to_wait: int | none = none suppress_log: bool | none = none populate_app_call_resources: bool | none = none @dataclass(kw_only=true, frozen=true) class transactionconfirmation: method: str</file><file name="models/simulate.py">dataclasses import dataclass __all__ = ["simulationtrace"] @dataclass class simulationtrace: app_budget_added: int | none app_budget_consumed: int | none failure_message: str | none exec_trace: dict[str, object]</file><file name="models/__init__.py">algokit_utils._legacy_v2.models import * # noqa: f403 algokit_utils.models.account import * # noqa: f403 algokit_utils.models.amount import * # noqa: f403 algokit_utils.models.application import * # noqa: f403 algokit_utils.models.network import * # noqa: f403 algokit_utils.models.simulate import * # noqa: f403 algokit_utils.models.state import * # noqa: f403 algokit_utils.models.transaction import * # noqa: f403</file><file name="models/application.py">dataclasses import dataclass typing import type_checking import algosdk algosdk.source_map import sourcemap type_checking: pass __all__ = [ "appcompilationresult", "appinformation", "appsourcemaps", "appstate", "compiledteal", ] @dataclass(kw_only=true, frozen=true) class appstate: key_raw: bytes key_base64: str value_raw: bytes | none value_base64: str | none value: str | int @dataclass(kw_only=true, frozen=true) class appinformation: app_id: int app_address: str approval_program: bytes clear_state_program: bytes creator: str global_state: dict[str, appstate] local_ints: int local_byte_slices: int global_ints: int global_byte_slices: int extra_program_pages: int | none @dataclass(kw_only=true, frozen=true) class compiledteal: teal: str compiled: bytes compiled_hash: str compiled_base64_to_bytes: bytes source_map: algosdk.source_map.sourcemap | none @dataclass(kw_only=true, frozen=true) class appcompilationresult: compiled_approval: compiledteal compiled_clear: compiledteal @dataclass(kw_only=true, frozen=true) class appsourcemaps: approval_source_map: sourcemap | none = none clear_source_map: sourcemap | none = none</file><file name="models/network.py">import dataclasses __all__ = [ "algoclientconfig", "algoclientconfigs", ] @dataclasses.dataclass class algoclientconfig: """connection details connecting {py:class}`algosdk.v2client.algod.algodclient` {py:class}`algosdk.v2client.indexer.indexerclient`""" server: str """url service e.g. `http://localhost:4001` `https://testnet-api.algonode.cloud`""" token: str | none = none """api token authenticate service""" port: str | int | none = none @dataclasses.dataclass class algoclientconfigs: algod_config: algoclientconfig indexer_config: algoclientconfig | none kmd_config: algoclientconfig | none</file><file name="models/state.py">import base64 collections.abc import mapping dataclasses import dataclass enum import intenum typing import typealias algosdk.atomic_transaction_composer import accounttransactionsigner algosdk.box_reference import boxreference algosdkboxreference __all__ = [ "boxidentifier", "boxname", "boxreference", "boxvalue", "datatypeflag", "tealtemplateparams", ] @dataclass(kw_only=true, frozen=true) class boxname: name: str name_raw: bytes name_base64: str @dataclass(kw_only=true, frozen=true) class boxvalue: name: boxname value: bytes class datatypeflag(intenum): bytes = 1 uint = 2 tealtemplateparams: typealias = mapping[str, str | int | bytes] | dict[str, str | int | bytes] boxidentifier: typealias = str | bytes | accounttransactionsigner class boxreference(algosdkboxreference): def __init__(self, app_id: int, name: bytes | str): super().__init__(app_index=app_id, name=self._b64_decode(name)) def __eq__(self, other: object) -&gt; bool: isinstance(other, (boxreference | algosdkboxreference)): return self.app_index == other.app_index self.name == other.name return false def _b64_decode(self, value: str | bytes) -&gt; bytes: isinstance(value, str): try: return base64.b64decode(value) except exception: return value.encode("utf-8") return value</file><file name="models/account.py">import dataclasses import algosdk import algosdk.atomic_transaction_composer algosdk.atomic_transaction_composer import accounttransactionsigner, transactionsigner algosdk.transaction import multisig, multisigtransaction __all__ = ["dispenser_account_name", "account", "multisigaccount", "multisigmetadata"] dispenser_account_name = "dispenser" @dataclasses.dataclass(kw_only=true) class account: """holds private_key address account""" private_key: str """base64 encoded private key""" address: str = dataclasses.field(default="") """address account""" def __post_init__(self) -&gt; none: self.address: self.address = str(algosdk.account.address_from_private_key(self.private_key)) @property def public_key(self) -&gt; bytes: """the public key account""" public_key = algosdk.encoding.decode_address(self.address) assert isinstance(public_key, bytes) return public_key @property def signer(self) -&gt; accounttransactionsigner: """an accounttransactionsigner account""" return accounttransactionsigner(self.private_key) @staticmethod def new_account() -&gt; "account": private_key, address = algosdk.account.generate_account() return account(private_key=private_key) @dataclasses.dataclass(kw_only=true) class multisigmetadata: version: int threshold: int addresses: list[str] @dataclasses.dataclass(kw_only=true) class multisigaccount: """account wrapper supports partial full multisig signing.""" _params: multisigmetadata _signing_accounts: list[account] _addr: str _signer: transactionsigner _multisig: multisig def __init__(self, multisig_params: multisigmetadata, signing_accounts: list[account]) -&gt; none: """initialize new multisig account. args: multisig_params: parameters multisig account signing_accounts: list accounts sign """ self._params = multisig_params self._signing_accounts = signing_accounts self._multisig = multisig(multisig_params.version, multisig_params.threshold, multisig_params.addresses) self._addr = str(self._multisig.address()) self._signer = algosdk.atomic_transaction_composer.multisigtransactionsigner( self._multisig, [account.private_key account signing_accounts], ) @property def params(self) -&gt; multisigmetadata: """the parameters multisig account.""" return self._params @property def signing_accounts(self) -&gt; list[account]: """the list accounts present sign.""" return self._signing_accounts @property def address(self) -&gt; str: """the address multisig account.""" return self._addr @property def signer(self) -&gt; transactionsigner: """the transaction signer multisig account.""" return self._signer def sign(self, transaction: algosdk.transaction.transaction) -&gt; multisigtransaction: """sign given transaction. args: transaction: either transaction object raw, partially signed transaction returns: transaction signed present signers """ msig_txn = multisigtransaction( transaction, self._multisig, ) signer self._signing_accounts: msig_txn.sign(signer.private_key) return msig_txn</file><file name="transactions/transaction_composer.py">__future__ import annotations import math dataclasses import dataclass typing import type_checking, any, union import algosdk import algosdk.atomic_transaction_composer import algosdk.v2client.models algosdk.atomic_transaction_composer import ( atomictransactioncomposer, transactionsigner, transactionwithsigner, ) algosdk.transaction import oncomplete algosdk.v2client.algod import algodclient typing_extensions import deprecated algokit_utils._debugging import simulate_and_persist_response, simulate_response algokit_utils.applications.abi import abireturn algokit_utils.applications.app_manager import appmanager algokit_utils.applications.app_spec.arc56 import method arc56method algokit_utils.config import config algokit_utils.models.transaction import sendparams, transactionwrapper algokit_utils.transactions.utils import encode_lease, populate_app_call_resources type_checking: collections.abc import callable algosdk.abi import method algosdk.v2client.algod import algodclient algosdk.v2client.models import simulatetraceconfig algokit_utils.applications.abi import abivalue algokit_utils.models.amount import algoamount algokit_utils.models.state import boxidentifier, boxreference algokit_utils.models.transaction import arc2transactionnote __all__ = [ "appcallmethodcallparams", "appcallparams", "appcreatemethodcallparams", "appcreateparams", "appdeletemethodcallparams", "appdeleteparams", "appupdatemethodcallparams", "appupdateparams", "assetconfigparams", "assetcreateparams", "assetdestroyparams", "assetfreezeparams", "assetoptinparams", "assetoptoutparams", "assettransferparams", "methodcallparams", "offlinekeyregistrationparams", "onlinekeyregistrationparams", "paymentparams", "sendatomictransactioncomposerresults", "transactioncomposer", "transactioncomposerbuildresult", "txnparams", "send_atomic_transaction_composer", ] logger = config.logger @dataclass(kw_only=true, frozen=true) class _commontxnparams: """ common transaction parameters. :param signer: function used sign transactions. :param rekey_to: change signing key sender given address. :param note: note attach transaction. :param lease: prevent multiple transactions lease included within validity window. :param static_fee: transaction fee. cases want use `extra_fee` unless setting fee 0 covered another transaction. :param extra_fee: fee pay addition suggested fee. useful covering inner transaction fees. :param max_fee: throw error fee transaction amount. :param validity_window: many rounds transaction valid for. :param first_valid_round: set first round transaction valid. left undefined, value algod used. set intentionally want time future. :param last_valid_round: last round transaction valid. recommended use validity_window instead. """ sender: str signer: transactionsigner | none = none rekey_to: str | none = none note: bytes | none = none lease: bytes | none = none static_fee: algoamount | none = none extra_fee: algoamount | none = none max_fee: algoamount | none = none validity_window: int | none = none first_valid_round: int | none = none last_valid_round: int | none = none @dataclass(kw_only=true, frozen=true) class _commontxnwithsendparams(_commontxnparams, sendparams): pass @dataclass(kw_only=true, frozen=true) class paymentparams( _commontxnwithsendparams, ): """ payment transaction parameters. :param receiver: account receive algo. :param amount: amount send. :param close_remainder_to: given, close sender account send remaining balance address. """ receiver: str amount: algoamount close_remainder_to: str | none = none @dataclass(kw_only=true, frozen=true) class assetcreateparams( _commontxnwithsendparams, ): """ asset creation parameters. :param total: total amount smallest divisible unit create. :param decimals: amount decimal places asset have. :param default_frozen: whether asset frozen default creator address. :param manager: address change manager, reserve, clawback, freeze addresses. permanently manager undefined empty string. :param reserve: address holds uncirculated supply. :param freeze: address freeze asset account. freezing permanently disabled undefined empty string. :param clawback: address clawback asset account. clawback permanently disabled undefined empty string. :param unit_name: short ticker name asset. :param asset_name: full name asset. :param url: metadata url asset. :param metadata_hash: hash metadata contained metadata url. """ total: int asset_name: str | none = none unit_name: str | none = none url: str | none = none decimals: int | none = none default_frozen: bool | none = none manager: str | none = none reserve: str | none = none freeze: str | none = none clawback: str | none = none metadata_hash: bytes | none = none @dataclass(kw_only=true, frozen=true) class assetconfigparams( _commontxnwithsendparams, ): """ asset configuration parameters. :param asset_id: id asset. :param manager: address change manager, reserve, clawback, freeze addresses. permanently manager undefined empty string. :param reserve: address holds uncirculated supply. :param freeze: address freeze asset account. freezing permanently disabled undefined empty string. :param clawback: address clawback asset account. clawback permanently disabled undefined empty string. """ asset_id: int manager: str | none = none reserve: str | none = none freeze: str | none = none clawback: str | none = none @dataclass(kw_only=true, frozen=true) class assetfreezeparams( _commontxnwithsendparams, ): """ asset freeze parameters. :param asset_id: id asset. :param account: account freeze unfreeze. :param frozen: whether assets account frozen. """ asset_id: int account: str frozen: bool @dataclass(kw_only=true, frozen=true) class assetdestroyparams( _commontxnwithsendparams, ): """ asset destruction parameters. :param asset_id: id asset. """ asset_id: int @dataclass(kw_only=true, frozen=true) class onlinekeyregistrationparams( _commontxnwithsendparams, ): """ online key registration parameters. :param vote_key: root participation public key. :param selection_key: vrf public key. :param vote_first: first round participation key valid. confused `first_valid` round keyreg transaction. :param vote_last: last round participation key valid. confused `last_valid` round keyreg transaction. :param vote_key_dilution: dilution 2-level participation key. determines interval (number rounds) generating new ephemeral keys. :param state_proof_key: 64 byte state proof public key commitment. """ vote_key: str selection_key: str vote_first: int vote_last: int vote_key_dilution: int state_proof_key: bytes | none = none @dataclass(kw_only=true, frozen=true) class offlinekeyregistrationparams(_commontxnwithsendparams): """ offline key registration parameters. """ prevent_account_from_ever_participating_again: bool @dataclass(kw_only=true, frozen=true) class assettransferparams( _commontxnwithsendparams, ): """ asset transfer parameters. :param asset_id: id asset. :param amount: amount asset transfer (smallest divisible unit). :param receiver: account send asset to. :param clawback_target: account take asset from. :param close_asset_to: account close asset to. """ asset_id: int amount: int receiver: str clawback_target: str | none = none close_asset_to: str | none = none @dataclass(kw_only=true, frozen=true) class assetoptinparams( _commontxnwithsendparams, ): """ asset opt-in parameters. :param asset_id: id asset. """ asset_id: int @dataclass(kw_only=true, frozen=true) class assetoptoutparams( _commontxnwithsendparams, ): """ asset opt-out parameters. """ asset_id: int creator: str @dataclass(kw_only=true, frozen=true) class appcallparams(_commontxnwithsendparams): """ application call parameters. :param on_complete: oncomplete action. :param app_id: id application. :param approval_program: program execute oncompletes clearstate. :param clear_state_program: program execute clearstate oncomplete. :param schema: state schema app. immutable. :param args: application arguments. :param account_references: account references. :param app_references: app references. :param asset_references: asset references. :param extra_pages: number extra pages required programs. :param box_references: box references. """ on_complete: oncomplete app_id: int | none = none approval_program: str | bytes | none = none clear_state_program: str | bytes | none = none schema: dict[str, int] | none = none args: list[bytes] | none = none account_references: list[str] | none = none app_references: list[int] | none = none asset_references: list[int] | none = none extra_pages: int | none = none box_references: list[boxreference | boxidentifier] | none = none @dataclass(kw_only=true, frozen=true) class appcreateparams(_commontxnwithsendparams): """ application create parameters. :param approval_program: program execute oncompletes clearstate raw teal (string) compiled teal (bytes) :param clear_state_program: program execute clearstate oncomplete raw teal (string) compiled teal (bytes) :param schema: state schema app. immutable. :param on_complete: oncomplete action (cannot clearstate) :param args: application arguments :param account_references: account references :param app_references: app references :param asset_references: asset references :param box_references: box references :param extra_program_pages: number extra pages required programs """ approval_program: str | bytes clear_state_program: str | bytes schema: dict[str, int] | none = none on_complete: oncomplete | none = none args: list[bytes] | none = none account_references: list[str] | none = none app_references: list[int] | none = none asset_references: list[int] | none = none box_references: list[boxreference | boxidentifier] | none = none extra_program_pages: int | none = none @dataclass(kw_only=true, frozen=true) class appupdateparams( _commontxnwithsendparams, ): """ application update parameters. :param app_id: id application :param approval_program: program execute oncompletes clearstate raw teal (string) compiled teal (bytes) :param clear_state_program: program execute clearstate oncomplete raw teal (string) compiled teal (bytes) """ app_id: int approval_program: str | bytes clear_state_program: str | bytes args: list[bytes] | none = none account_references: list[str] | none = none app_references: list[int] | none = none asset_references: list[int] | none = none box_references: list[boxreference | boxidentifier] | none = none on_complete: oncomplete | none = none @dataclass(kw_only=true, frozen=true) class appdeleteparams( _commontxnwithsendparams, ): """ application delete parameters. :param app_id: id application """ app_id: int args: list[bytes] | none = none account_references: list[str] | none = none app_references: list[int] | none = none asset_references: list[int] | none = none box_references: list[boxreference | boxidentifier] | none = none on_complete: oncomplete = oncomplete.deleteapplicationoc @dataclass(kw_only=true, frozen=true) class _baseappmethodcall(_commontxnwithsendparams): """base class abi method calls.""" app_id: int method: method args: list | none = none account_references: list[str] | none = none app_references: list[int] | none = none asset_references: list[int] | none = none box_references: list[boxreference | boxidentifier] | none = none schema: dict[str, int] | none = none @dataclass(kw_only=true, frozen=true) class appmethodcallparams(_commontxnwithsendparams): """ method call parameters. :param app_id: id application :param method: abi method call :param args: arguments abi method :param on_complete: oncomplete action (cannot updateapplication clearstate) """ app_id: int method: method args: list[bytes] | none = none on_complete: oncomplete | none = none account_references: list[str] | none = none app_references: list[int] | none = none asset_references: list[int] | none = none box_references: list[boxreference | boxidentifier] | none = none @dataclass(kw_only=true, frozen=true) class appcallmethodcallparams(_baseappmethodcall): """parameters regular abi method call. :param app_id: id application :param method: abi method call :param args: arguments abi method, either: * abi value * transaction explicit signer * transaction (where signer automatically assigned) * another method call * none (represents placeholder transaction argument) :param on_complete: oncomplete action (cannot updateapplication clearstate) """ app_id: int on_complete: oncomplete | none = none @dataclass(kw_only=true, frozen=true) class appcreatemethodcallparams(_baseappmethodcall): """parameters abi method call creates application. :param approval_program: program execute oncompletes clearstate :param clear_state_program: program execute clearstate oncomplete :param schema: state schema app :param on_complete: oncomplete action (cannot clearstate) :param extra_program_pages: number extra pages required programs """ approval_program: str | bytes clear_state_program: str | bytes schema: dict[str, int] | none = none on_complete: oncomplete | none = none extra_program_pages: int | none = none @dataclass(kw_only=true, frozen=true) class appupdatemethodcallparams(_baseappmethodcall): """parameters abi method call updates application. :param app_id: id application :param approval_program: program execute oncompletes clearstate :param clear_state_program: program execute clearstate oncomplete """ app_id: int approval_program: str | bytes clear_state_program: str | bytes on_complete: oncomplete = oncomplete.updateapplicationoc @dataclass(kw_only=true, frozen=true) class appdeletemethodcallparams(_baseappmethodcall): """parameters abi method call deletes application. :param app_id: id application """ app_id: int on_complete: oncomplete = oncomplete.deleteapplicationoc # type alias possible method call types methodcallparams = ( appcallmethodcallparams | appcreatemethodcallparams | appupdatemethodcallparams | appdeletemethodcallparams ) # type alias transaction arguments method calls appmethodcalltransactionargument = ( transactionwithsigner | algosdk.transaction.transaction | appcreatemethodcallparams | appupdatemethodcallparams | appcallmethodcallparams ) txnparams = union[ # noqa: up007 paymentparams, assetcreateparams, assetconfigparams, assetfreezeparams, assetdestroyparams, onlinekeyregistrationparams, assettransferparams, assetoptinparams, assetoptoutparams, appcallparams, appcreateparams, appupdateparams, appdeleteparams, methodcallparams, offlinekeyregistrationparams, ] @dataclass(frozen=true) class builttransactions: """ set transactions built transactioncomposer. :param transactions: built transactions. :param method_calls: abimethod objects associated transactions map keyed txn id. :param signers: transactionsigner objects associated transactions map keyed txn id. """ transactions: list[algosdk.transaction.transaction] method_calls: dict[int, method] signers: dict[int, transactionsigner] @dataclass class transactioncomposerbuildresult: atc: atomictransactioncomposer transactions: list[transactionwithsigner] method_calls: dict[int, method] @dataclass class sendatomictransactioncomposerresults: """results sending atomictransactioncomposer transaction group""" group_id: str """the group id transaction group""" confirmations: list[algosdk.v2client.algod.algodresponsetype] """the confirmation info transaction""" tx_ids: list[str] """the transaction ids sent""" transactions: list[transactionwrapper] """the transactions sent""" returns: list[abireturn] """the abi return values abi method calls""" simulate_response: dict[str, any] | none = none def send_atomic_transaction_composer( # noqa: c901, plr0912 atc: atomictransactioncomposer, algod: algodclient, *, max_rounds_to_wait: int | none = 5, skip_waiting: bool = false, suppress_log: bool | none = none, populate_resources: bool | none = none, ) -&gt; sendatomictransactioncomposerresults: """send atomictransactioncomposer transaction group args: atc: atomictransactioncomposer send algod: algod client use max_rounds_to_wait: maximum number rounds wait confirmation skip_waiting: true, wait transaction confirmation suppress_log: true, suppress logging populate_resources: true, populate app call resources returns: results sending transaction group raises: exception: error sending transactions """ try: # build transactions transactions_with_signer = atc.build_group() populate_resources ( populate_resources none config.populate_app_call_resource any(isinstance(t.txn, algosdk.transaction.applicationcalltxn) transactions_with_signer) ): atc = populate_app_call_resources(atc, algod) transactions_to_send = [t.txn transactions_with_signer] # get group id multiple transactions group_id = none len(transactions_to_send) &gt; 1: group_id = transactions_to_send[0].group.hex() transactions_to_send[0].group else none suppress_log: logger.info(f"sending group {len(transactions_to_send)} transactions ({group_id})") logger.debug(f"transaction ids ({group_id}): {[t.get_txid() transactions_to_send]}") # simulate debug enabled config.debug config.trace_all config.project_root: simulate_and_persist_response( atc, config.project_root, algod, config.trace_buffer_size_mb, ) # execute transactions result = atc.execute(algod, wait_rounds=max_rounds_to_wait 5) # log results suppress_log: len(transactions_to_send) &gt; 1: logger.info(f"group transaction ({group_id}) sent {len(transactions_to_send)} transactions") else: logger.info(f"sent transaction id {transactions_to_send[0].get_txid()}") # get confirmations skipping confirmations = none skip_waiting: confirmations = [algod.pending_transaction_info(t.get_txid()) transactions_to_send] # return results return sendatomictransactioncomposerresults( group_id=group_id "", confirmations=confirmations [], tx_ids=[t.get_txid() transactions_to_send], transactions=[transactionwrapper(t) transactions_to_send], returns=[abireturn(r) r result.abi_results], ) except exception e: # handle error debug info enabled config.debug: logger.error( "received error executing atomic transaction composer debug flag enabled; " "attempting simulation get information" ) simulate = none config.project_root config.trace_all: # simulate trace_all disabled project_root set simulate = simulate_and_persist_response(atc, config.project_root, algod, config.trace_buffer_size_mb) else: simulate = simulate_response(atc, algod) traces = [] simulate simulate.failed_at: txn_group simulate.simulate_response["txn-groups"]: app_budget = txn_group.get("app-budget-added") app_budget_consumed = txn_group.get("app-budget-consumed") failure_message = txn_group.get("failure-message") txn_result = txn_group.get("txn-results", [{}])[0] exec_trace = txn_result.get("exec-trace", {}) traces.append( { "trace": exec_trace, "app_budget": app_budget, "app_budget_consumed": app_budget_consumed, "failure_message": failure_message, } ) error = exception(f"transaction failed: {e}") error.traces = traces # type: ignore[attr-defined] raise error e logger.error("received error executing atomic transaction composer, information enable debug flag") raise e class transactioncomposer: """ class composing managing algorand transactions using algosdk library. attributes: txn_method_map (dict[str, algosdk.abi.method]): dictionary maps transaction ids corresponding abi methods. txns (list[union[transactionwithsigner, txnparams, atomictransactioncomposer]]): list transactions yet composed. atc (atomictransactioncomposer): instance atomictransactioncomposer used compose transactions. algod (algodclient): algodclient instance used composer suggested params. get_suggested_params (callable[[], algosdk.future.transaction.suggestedparams]): function returns suggested parameters transactions. get_signer (callable[[str], transactionsigner]): function takes address input returns transactionsigner address. default_validity_window (int): default validity window transactions. """ null_signer: transactionsigner = algosdk.atomic_transaction_composer.emptysigner() def __init__( self, algod: algodclient, get_signer: callable[[str], transactionsigner], get_suggested_params: callable[[], algosdk.transaction.suggestedparams] | none = none, default_validity_window: int | none = none, app_manager: appmanager | none = none, ): """ initialize instance transactioncomposer class. args: algod (algodclient): instance algodclient used get suggested params send transactions. get_signer (callable[[str], transactionsigner]): function takes address input returns transactionsigner address. get_suggested_params (optional[callable[[], algosdk.future.transaction.suggestedparams]], optional): function returns suggested parameters transactions. provided, defaults using algod.suggested_params(). defaults none. default_validity_window (optional[int], optional): default validity window transactions. provided, defaults 10. defaults none. """ self._txn_method_map: dict[str, algosdk.abi.method] = {} self._txns: list[transactionwithsigner | txnparams | atomictransactioncomposer] = [] self._atc: atomictransactioncomposer = atomictransactioncomposer() self._algod: algodclient = algod self._default_get_send_params = lambda: self._algod.suggested_params() self._get_suggested_params = get_suggested_params self._default_get_send_params self._get_signer: callable[[str], transactionsigner] = get_signer self._default_validity_window: int = default_validity_window 10 self._app_manager = app_manager appmanager(algod) def add_transaction( self, transaction: algosdk.transaction.transaction, signer: transactionsigner | none = none ) -&gt; transactioncomposer: self._txns.append(transactionwithsigner(txn=transaction, signer=signer self._get_signer(transaction.sender))) return self def add_payment(self, params: paymentparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_asset_create(self, params: assetcreateparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_asset_config(self, params: assetconfigparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_asset_freeze(self, params: assetfreezeparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_asset_destroy(self, params: assetdestroyparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_asset_transfer(self, params: assettransferparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_asset_opt_in(self, params: assetoptinparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_asset_opt_out(self, params: assetoptoutparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_app_create(self, params: appcreateparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_app_update(self, params: appupdateparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_app_delete(self, params: appdeleteparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_app_call(self, params: appcallparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_app_create_method_call(self, params: appcreatemethodcallparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_app_update_method_call(self, params: appupdatemethodcallparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_app_delete_method_call(self, params: appdeletemethodcallparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_app_call_method_call(self, params: appcallmethodcallparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_online_key_registration(self, params: onlinekeyregistrationparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_offline_key_registration(self, params: offlinekeyregistrationparams) -&gt; transactioncomposer: self._txns.append(params) return self def add_atc(self, atc: atomictransactioncomposer) -&gt; transactioncomposer: self._txns.append(atc) return self def count(self) -&gt; int: return len(self.build_transactions().transactions) def build(self) -&gt; transactioncomposerbuildresult: self._atc.get_status() == algosdk.atomic_transaction_composer.atomictransactioncomposerstatus.building: suggested_params = self._get_suggested_params() txn_with_signers: list[transactionwithsigner] = [] txn self._txns: txn_with_signers.extend(self._build_txn(txn, suggested_params)) ts txn_with_signers: self._atc.add_transaction(ts) method = self._txn_method_map.get(ts.txn.get_txid()) method: self._atc.method_dict[len(self._atc.txn_list) - 1] = method return transactioncomposerbuildresult( atc=self._atc, transactions=self._atc.build_group(), method_calls=self._atc.method_dict, ) def rebuild(self) -&gt; transactioncomposerbuildresult: self._atc = atomictransactioncomposer() return self.build() def build_transactions(self) -&gt; builttransactions: suggested_params = self._get_suggested_params() transactions: list[algosdk.transaction.transaction] = [] method_calls: dict[int, method] = {} signers: dict[int, transactionsigner] = {} idx = 0 txn self._txns: txn_with_signers: list[transactionwithsigner] = [] isinstance(txn, methodcallparams): txn_with_signers.extend(self._build_method_call(txn, suggested_params)) else: txn_with_signers.extend(self._build_txn(txn, suggested_params)) ts txn_with_signers: transactions.append(ts.txn) ts.signer ts.signer != self.null_signer: signers[idx] = ts.signer method = self._txn_method_map.get(ts.txn.get_txid()) method: method_calls[idx] = method idx += 1 return builttransactions(transactions=transactions, method_calls=method_calls, signers=signers) @deprecated("use send() instead") def execute( self, *, max_rounds_to_wait: int | none = none, ) -&gt; sendatomictransactioncomposerresults: return self.send( max_rounds_to_wait=max_rounds_to_wait, ) def send( self, *, max_rounds_to_wait: int | none = none, suppress_log: bool | none = none, populate_app_call_resources: bool | none = none, ) -&gt; sendatomictransactioncomposerresults: group = self.build().transactions wait_rounds = max_rounds_to_wait wait_rounds none: last_round = max(txn.txn.last_valid_round txn group) first_round = self._get_suggested_params().first wait_rounds = last_round - first_round + 1 try: return send_atomic_transaction_composer( self._atc, self._algod, max_rounds_to_wait=wait_rounds, suppress_log=suppress_log, populate_resources=populate_app_call_resources, ) except algosdk.error.algodhttperror e: raise exception(f"transaction failed: {e}") e def simulate( self, allow_more_logs: bool | none = none, allow_empty_signatures: bool | none = none, allow_unnamed_resources: bool | none = none, extra_opcode_budget: int | none = none, exec_trace_config: simulatetraceconfig | none = none, simulation_round: int | none = none, skip_signatures: int | none = none, ) -&gt; sendatomictransactioncomposerresults: atc = atomictransactioncomposer() skip_signatures else self._atc skip_signatures: allow_empty_signatures = true transactions = self.build_transactions() txn transactions.transactions: atc.add_transaction(transactionwithsigner(txn=txn, signer=transactioncomposer.null_signer)) atc.method_dict = transactions.method_calls else: self.build() config.debug config.project_root config.trace_all: response = simulate_and_persist_response( atc, config.project_root, self._algod, config.trace_buffer_size_mb, allow_more_logs, allow_empty_signatures, allow_unnamed_resources, extra_opcode_budget, exec_trace_config, simulation_round, skip_signatures, ) return sendatomictransactioncomposerresults( confirmations=response.simulate_response.get("txn-groups", [{"txn-results": [{"txn-result": {}}]}])[0][ "txn-results" ], transactions=[transactionwrapper(txn.txn) txn atc.txn_list], tx_ids=response.tx_ids, group_id=atc.txn_list[-1].txn.group "", simulate_response=response.simulate_response, returns=[abireturn(r) r response.abi_results], ) response = simulate_response( atc, self._algod, allow_more_logs, allow_empty_signatures, allow_unnamed_resources, extra_opcode_budget, exec_trace_config, simulation_round, skip_signatures, ) confirmation_results = response.simulate_response.get("txn-groups", [{"txn-results": [{"txn-result": {}}]}])[0][ "txn-results" ] return sendatomictransactioncomposerresults( confirmations=[txn["txn-result"] txn confirmation_results], transactions=[transactionwrapper(txn.txn) txn atc.txn_list], tx_ids=response.tx_ids, group_id=atc.txn_list[-1].txn.group "", simulate_response=response.simulate_response, returns=[abireturn(r) r response.abi_results], ) @staticmethod def arc2_note(note: arc2transactionnote) -&gt; bytes: """ create encoded transaction note follows arc-2 spec. https://github.com/algorandfoundation/arcs/blob/main/arcs/arc-0002.md :param note: arc-2 note encode. """ arc2_payload = f"{note['dapp_name']}:{note['format']}{note['data']}" return arc2_payload.encode("utf-8") def _build_atc(self, atc: atomictransactioncomposer) -&gt; list[transactionwithsigner]: group = atc.build_group() ts group: ts.txn.group = none method = atc.method_dict.get(len(group) - 1) method: self._txn_method_map[group[-1].txn.get_txid()] = method return group def _common_txn_build_step( self, build_txn: callable[[dict], algosdk.transaction.transaction], params: _commontxnwithsendparams, txn_params: dict, ) -&gt; algosdk.transaction.transaction: # clone suggested params txn_params["sp"] = ( algosdk.transaction.suggestedparams(**txn_params["sp"].__dict__) "sp" txn_params else none ) params.lease: txn_params["lease"] = encode_lease(params.lease) params.rekey_to: txn_params["rekey_to"] = params.rekey_to params.note: txn_params["note"] = params.note params.static_fee none txn_params["sp"]: txn_params["sp"].fee = params.static_fee.micro_algos txn_params["sp"].flat_fee = true isinstance(txn_params.get("method"), arc56method): txn_params["method"] = txn_params["method"].to_abi_method() txn = build_txn(txn_params) params.extra_fee: txn.fee += params.extra_fee.micro_algos params.max_fee txn.fee &gt; params.max_fee.micro_algos: raise valueerror(f"transaction fee {txn.fee} greater max_fee {params.max_fee}") return txn def _build_method_call( # noqa: c901, plr0912 self, params: methodcallparams, suggested_params: algosdk.transaction.suggestedparams ) -&gt; list[transactionwithsigner]: method_args: list[abivalue | transactionwithsigner] = [] arg_offset = 0 params.args: _, arg enumerate(params.args): self._is_abi_value(arg): method_args.append(arg) continue isinstance(arg, transactionwithsigner): method_args.append(arg) continue isinstance(arg, algosdk.transaction.transaction): # wrap transactionwithsigner method_args.append( transactionwithsigner(txn=arg, signer=params.signer self._get_signer(params.sender)) ) continue match arg: case ( appcreatemethodcallparams() | appcallmethodcallparams() | appupdatemethodcallparams() | appdeletemethodcallparams() ): temp_txn_with_signers = self._build_method_call(arg, suggested_params) method_args.extend(temp_txn_with_signers) arg_offset += len(temp_txn_with_signers) - 1 continue case appcallparams(): txn = self._build_app_call(arg, suggested_params) case paymentparams(): txn = self._build_payment(arg, suggested_params) case assetoptinparams(): txn = self._build_asset_transfer( assettransferparams(**arg.__dict__, receiver=arg.sender, amount=0), suggested_params ) case assetcreateparams(): txn = self._build_asset_create(arg, suggested_params) case assetconfigparams(): txn = self._build_asset_config(arg, suggested_params) case assetdestroyparams(): txn = self._build_asset_destroy(arg, suggested_params) case assetfreezeparams(): txn = self._build_asset_freeze(arg, suggested_params) case assettransferparams(): txn = self._build_asset_transfer(arg, suggested_params) case onlinekeyregistrationparams() | offlinekeyregistrationparams(): txn = self._build_key_reg(arg, suggested_params) case _: raise valueerror(f"unsupported method arg transaction type: {arg!s}") method_args.append( transactionwithsigner(txn=txn, signer=params.signer self._get_signer(params.sender)) ) continue method_atc = atomictransactioncomposer() txn_params = { "app_id": params.app_id 0, "method": params.method, "sender": params.sender, "sp": suggested_params, "signer": params.signer self._get_signer(params.sender), "method_args": method_args, "on_complete": params.on_complete algosdk.transaction.oncomplete.noopoc, "note": params.note, "lease": params.lease, "boxes": [appmanager.get_box_reference(ref) ref params.box_references] params.box_references else none, "foreign_apps": params.app_references, "foreign_assets": params.asset_references, "accounts": params.account_references, "global_schema": algosdk.transaction.stateschema( num_uints=params.schema.get("global_ints", 0), num_byte_slices=params.schema.get("global_bytes", 0), ) params.schema else none, "local_schema": algosdk.transaction.stateschema( num_uints=params.schema.get("local_ints", 0), num_byte_slices=params.schema.get("local_bytes", 0), ) params.schema else none, "approval_program": getattr(params, "approval_program", none), "clear_program": getattr(params, "clear_state_program", none), "rekey_to": params.rekey_to, } def _add_method_call_and_return_txn(x: dict) -&gt; algosdk.transaction.transaction: method_atc.add_method_call(**x) return method_atc.build_group()[-1].txn self._common_txn_build_step(lambda x: _add_method_call_and_return_txn(x), params, txn_params) return self._build_atc(method_atc) def _build_payment( self, params: paymentparams, suggested_params: algosdk.transaction.suggestedparams ) -&gt; algosdk.transaction.transaction: txn_params = { "sender": params.sender, "sp": suggested_params, "receiver": params.receiver, "amt": params.amount.micro_algos, "close_remainder_to": params.close_remainder_to, } return self._common_txn_build_step(lambda x: algosdk.transaction.paymenttxn(**x), params, txn_params) def _build_asset_create( self, params: assetcreateparams, suggested_params: algosdk.transaction.suggestedparams ) -&gt; algosdk.transaction.transaction: txn_params = { "sender": params.sender, "sp": suggested_params, "total": params.total, "default_frozen": params.default_frozen false, "unit_name": params.unit_name "", "asset_name": params.asset_name "", "manager": params.manager, "reserve": params.reserve, "freeze": params.freeze, "clawback": params.clawback, "url": params.url "", "metadata_hash": params.metadata_hash, "decimals": params.decimals 0, } return self._common_txn_build_step(lambda x: algosdk.transaction.assetcreatetxn(**x), params, txn_params) def _build_app_call( self, params: appcallparams | appupdateparams | appcreateparams | appdeleteparams, suggested_params: algosdk.transaction.suggestedparams, ) -&gt; algosdk.transaction.transaction: app_id = getattr(params, "app_id", 0) approval_program = none clear_program = none isinstance(params, appupdateparams | appcreateparams): isinstance(params.approval_program, str): approval_program = self._app_manager.compile_teal(params.approval_program).compiled_base64_to_bytes elif isinstance(params.approval_program, bytes): approval_program = params.approval_program isinstance(params.clear_state_program, str): clear_program = self._app_manager.compile_teal(params.clear_state_program).compiled_base64_to_bytes elif isinstance(params.clear_state_program, bytes): clear_program = params.clear_state_program approval_program_len = len(approval_program) approval_program else 0 clear_program_len = len(clear_program) clear_program else 0 sdk_params = { "sender": params.sender, "sp": suggested_params, "app_args": params.args, "on_complete": params.on_complete algosdk.transaction.oncomplete.noopoc, "accounts": params.account_references, "foreign_apps": params.app_references, "foreign_assets": params.asset_references, "boxes": params.box_references, "approval_program": approval_program, "clear_program": clear_program, } txn_params = {**sdk_params, "index": app_id} app_id isinstance(params, appcreateparams): sdk_params["approval_program"] sdk_params["clear_program"]: raise valueerror("approval_program clear_program required application creation") params.schema: raise valueerror("schema required application creation") txn_params = { **txn_params, "global_schema": algosdk.transaction.stateschema( num_uints=params.schema.get("global_ints", 0), num_byte_slices=params.schema.get("global_bytes", 0), ), "local_schema": algosdk.transaction.stateschema( num_uints=params.schema.get("local_ints", 0), num_byte_slices=params.schema.get("local_bytes", 0), ), "extra_pages": params.extra_program_pages math.floor((approval_program_len + clear_program_len) / algosdk.constants.app_page_max_size) params.extra_program_pages else 0, } return self._common_txn_build_step(lambda x: algosdk.transaction.applicationcalltxn(**x), params, txn_params) def _build_asset_config( self, params: assetconfigparams, suggested_params: algosdk.transaction.suggestedparams ) -&gt; algosdk.transaction.transaction: txn_params = { "sender": params.sender, "sp": suggested_params, "index": params.asset_id, "manager": params.manager, "reserve": params.reserve, "freeze": params.freeze, "clawback": params.clawback, "strict_empty_address_check": false, } return self._common_txn_build_step(lambda x: algosdk.transaction.assetconfigtxn(**x), params, txn_params) def _build_asset_destroy( self, params: assetdestroyparams, suggested_params: algosdk.transaction.suggestedparams ) -&gt; algosdk.transaction.transaction: txn_params = { "sender": params.sender, "sp": suggested_params, "index": params.asset_id, } return self._common_txn_build_step(lambda x: algosdk.transaction.assetdestroytxn(**x), params, txn_params) def _build_asset_freeze( self, params: assetfreezeparams, suggested_params: algosdk.transaction.suggestedparams ) -&gt; algosdk.transaction.transaction: txn_params = { "sender": params.sender, "sp": suggested_params, "index": params.asset_id, "target": params.account, "new_freeze_state": params.frozen, } return self._common_txn_build_step(lambda x: algosdk.transaction.assetfreezetxn(**x), params, txn_params) def _build_asset_transfer( self, params: assettransferparams, suggested_params: algosdk.transaction.suggestedparams ) -&gt; algosdk.transaction.transaction: txn_params = { "sender": params.sender, "sp": suggested_params, "receiver": params.receiver, "amt": params.amount, "index": params.asset_id, "close_assets_to": params.close_asset_to, "revocation_target": params.clawback_target, } return self._common_txn_build_step(lambda x: algosdk.transaction.assettransfertxn(**x), params, txn_params) def _build_key_reg( self, params: onlinekeyregistrationparams | offlinekeyregistrationparams, suggested_params: algosdk.transaction.suggestedparams, ) -&gt; algosdk.transaction.transaction: isinstance(params, onlinekeyregistrationparams): txn_params = { "sender": params.sender, "sp": suggested_params, "votekey": params.vote_key, "selkey": params.selection_key, "votefst": params.vote_first, "votelst": params.vote_last, "votekd": params.vote_key_dilution, "rekey_to": params.rekey_to, "nonpart": false, "sprfkey": params.state_proof_key, } return self._common_txn_build_step(lambda x: algosdk.transaction.keyregtxn(**x), params, txn_params) return self._common_txn_build_step( lambda x: algosdk.transaction.keyregtxn(**x), params, { "sender": params.sender, "sp": suggested_params, "nonpart": params.prevent_account_from_ever_participating_again, "votekey": none, "selkey": none, "votefst": none, "votelst": none, "votekd": none, }, ) def _is_abi_value(self, x: bool | float | str | bytes | list | txnparams) -&gt; bool: isinstance(x, list | tuple): return len(x) == 0 all(self._is_abi_value(item) item x) return isinstance(x, bool | int | float | str | bytes) def _build_txn( # noqa: c901, plr0912, plr0911 self, txn: transactionwithsigner | txnparams | atomictransactioncomposer, suggested_params: algosdk.transaction.suggestedparams, ) -&gt; list[transactionwithsigner]: match txn: case transactionwithsigner(): return [txn] case atomictransactioncomposer(): return self._build_atc(txn) case algosdk.transaction.transaction(): signer = self._get_signer(txn.sender) return [transactionwithsigner(txn=txn, signer=signer)] case ( appcreatemethodcallparams() | appcallmethodcallparams() | appupdatemethodcallparams() | appdeletemethodcallparams() ): return self._build_method_call(txn, suggested_params) signer = txn.signer self._get_signer(txn.sender) match txn: case paymentparams(): payment = self._build_payment(txn, suggested_params) return [transactionwithsigner(txn=payment, signer=signer)] case assetcreateparams(): asset_create = self._build_asset_create(txn, suggested_params) return [transactionwithsigner(txn=asset_create, signer=signer)] case appcallparams() | appupdateparams() | appcreateparams() | appdeleteparams(): app_call = self._build_app_call(txn, suggested_params) return [transactionwithsigner(txn=app_call, signer=signer)] case assetconfigparams(): asset_config = self._build_asset_config(txn, suggested_params) return [transactionwithsigner(txn=asset_config, signer=signer)] case assetdestroyparams(): asset_destroy = self._build_asset_destroy(txn, suggested_params) return [transactionwithsigner(txn=asset_destroy, signer=signer)] case assetfreezeparams(): asset_freeze = self._build_asset_freeze(txn, suggested_params) return [transactionwithsigner(txn=asset_freeze, signer=signer)] case assettransferparams(): asset_transfer = self._build_asset_transfer(txn, suggested_params) return [transactionwithsigner(txn=asset_transfer, signer=signer)] case assetoptinparams(): asset_transfer = self._build_asset_transfer( assettransferparams(**txn.__dict__, receiver=txn.sender, amount=0), suggested_params ) return [transactionwithsigner(txn=asset_transfer, signer=signer)] case assetoptoutparams(): txn_dict = txn.__dict__ creator = txn_dict.pop("creator") asset_transfer = self._build_asset_transfer( assettransferparams(**txn_dict, receiver=txn.sender, amount=0, close_asset_to=creator), suggested_params, ) return [transactionwithsigner(txn=asset_transfer, signer=signer)] case onlinekeyregistrationparams() | offlinekeyregistrationparams(): key_reg = self._build_key_reg(txn, suggested_params) return [transactionwithsigner(txn=key_reg, signer=signer)] case _: raise valueerror(f"unsupported txn: {txn}")</file><file name="transactions/__init__.py">algokit_utils.transactions.transaction_composer import * # noqa: f403 algokit_utils.transactions.transaction_creator import * # noqa: f403 algokit_utils.transactions.transaction_sender import * # noqa: f403 algokit_utils.transactions.utils import * # noqa: f403</file><file name="transactions/utils.py">import base64 copy import deepcopy typing import any, cast algosdk import logic, transaction algosdk.atomic_transaction_composer import atomictransactioncomposer, emptysigner, transactionwithsigner algosdk.error import atomictransactioncomposererror algosdk.v2client.algod import algodclient algosdk.v2client.models import simulaterequest, simulaterequesttransactiongroup algokit_utils.models.state import boxreference __all__ = [ "get_unnamed_app_call_resources_accessed", "populate_app_call_resources", ] # constants max_app_call_account_references = 4 max_app_call_foreign_references = 8 def _find_available_transaction_index( txns: list[transactionwithsigner], reference_type: str, reference: str | dict[str, any] | int ) -&gt; int: """find index first transaction accommodate new reference.""" def check_transaction(txn: transactionwithsigner) -&gt; bool: # skip application call transaction txn.txn.type != "appl": return false # get current counts (using get() default 0 pythonic null handling) accounts = len(getattr(txn.txn, "accounts", []) []) assets = len(getattr(txn.txn, "foreign_assets", []) []) apps = len(getattr(txn.txn, "foreign_apps", []) []) boxes = len(getattr(txn.txn, "boxes", []) []) # account references, check account limit reference_type == "account": return accounts &lt; max_app_call_account_references # asset holdings local state, need space account reference reference_type ("asset_holding", "app_local"): return ( accounts + assets + apps + boxes &lt; max_app_call_foreign_references - 1 accounts &lt; max_app_call_account_references ) # boxes non-zero app id, need space box app reference reference_type == "box" reference int(getattr(reference, "app", 0)) != 0: return accounts + assets + apps + boxes &lt; max_app_call_foreign_references - 1 # default case - check total references return accounts + assets + apps + boxes &lt; max_app_call_foreign_references # return first matching index -1 none found return next((i i, txn enumerate(txns) check_transaction(txn)), -1) def populate_app_call_resources(atc: atomictransactioncomposer, algod: algodclient) -&gt; atomictransactioncomposer: # noqa: c901, plr0915, plr0912 """ populate application call resources based simulation results. """ # get unnamed resources simulation unnamed_resources = get_unnamed_app_call_resources_accessed(atc, algod) group = atc.build_group() # process transaction-level resources i, txn_resources enumerate(unnamed_resources["txns"]): txn_resources isinstance(group[i].txn, transaction.applicationcalltxn): continue # validate unexpected resources txn_resources.get("boxes") txn_resources.get("extra-box-refs"): raise valueerror("unexpected boxes transaction level") txn_resources.get("applocals"): raise valueerror("unexpected app local transaction level") txn_resources.get("assetholdings"): raise valueerror("unexpected asset holding transaction level") # update application call fields app_txn = cast(transaction.applicationcalltxn, group[i].txn) accounts = list(getattr(app_txn, "accounts", []) []) foreign_apps = list(getattr(app_txn, "foreign_apps", []) []) foreign_assets = list(getattr(app_txn, "foreign_assets", []) []) boxes = list(getattr(app_txn, "boxes", []) []) # add new resources accounts.extend(txn_resources.get("accounts", [])) foreign_apps.extend(txn_resources.get("apps", [])) foreign_assets.extend(txn_resources.get("assets", [])) boxes.extend(txn_resources.get("boxes", [])) # validate limits len(accounts) &gt; max_app_call_account_references: raise valueerror( f"account reference limit {max_app_call_account_references} exceeded transaction {i}" ) total_refs = len(accounts) + len(foreign_assets) + len(foreign_apps) + len(boxes) total_refs &gt; max_app_call_foreign_references: raise valueerror( f"resource reference limit {max_app_call_foreign_references} exceeded transaction {i}" ) # update transaction app_txn.accounts = accounts app_txn.foreign_apps = foreign_apps app_txn.foreign_assets = foreign_assets app_txn.boxes = boxes def populate_group_resource( # noqa: c901, plr0912, plr0915 txns: list[transactionwithsigner], reference: str | dict[str, any] | int, ref_type: str ) -&gt; none: """helper function populate group-level resources matching typescript implementation""" def is_appl_below_limit(t: transactionwithsigner) -&gt; bool: isinstance(t.txn, transaction.applicationcalltxn): return false accounts = len(getattr(t.txn, "accounts", []) []) assets = len(getattr(t.txn, "foreign_assets", []) []) apps = len(getattr(t.txn, "foreign_apps", []) []) boxes = len(getattr(t.txn, "boxes", []) []) return accounts + assets + apps + boxes &lt; max_app_call_foreign_references # handle asset holding app local references first ref_type ("assetholding", "applocal"): ref_dict = cast(dict[str, any], reference) account = ref_dict["account"] # first try find transaction account already available txn_idx = next( ( i, enumerate(txns) is_appl_below_limit(t) isinstance(t.txn, transaction.applicationcalltxn) ( account (getattr(t.txn, "accounts", []) []) account ( logic.get_application_address(app_id) app_id (getattr(t.txn, "foreign_apps", []) []) ) any(str(account) str(v) v t.txn.__dict__.values()) ) ), -1, ) txn_idx &gt;= 0: app_txn = cast(transaction.applicationcalltxn, txns[txn_idx].txn) ref_type == "assetholding": asset_id = ref_dict["asset"] app_txn.foreign_assets = [*list(getattr(app_txn, "foreign_assets", []) []), asset_id] else: app_id = ref_dict["app"] app_txn.foreign_apps = [*list(getattr(app_txn, "foreign_apps", []) []), app_id] return # try find transaction already app/asset available txn_idx = next( ( i, enumerate(txns) is_appl_below_limit(t) isinstance(t.txn, transaction.applicationcalltxn) len(getattr(t.txn, "accounts", []) []) &lt; max_app_call_account_references ( ( ref_type == "assetholding" ref_dict["asset"] (getattr(t.txn, "foreign_assets", []) []) ) ( ref_type == "applocal" ( ref_dict["app"] (getattr(t.txn, "foreign_apps", []) []) t.txn.index == ref_dict["app"] ) ) ) ), -1, ) txn_idx &gt;= 0: app_txn = cast(transaction.applicationcalltxn, txns[txn_idx].txn) accounts = list(getattr(app_txn, "accounts", []) []) accounts.append(account) app_txn.accounts = accounts return # handle box references ref_type == "box": box_ref: tuple[int, bytes] = (reference["app"], base64.b64decode(reference["name"])) # type: ignore # noqa: pgh003 # try find transaction already app available txn_idx = next( ( i, enumerate(txns) is_appl_below_limit(t) isinstance(t.txn, transaction.applicationcalltxn) (box_ref[0] (getattr(t.txn, "foreign_apps", []) []) t.txn.index == box_ref[0]) ), -1, ) txn_idx &gt;= 0: app_txn = cast(transaction.applicationcalltxn, txns[txn_idx].txn) boxes = list(getattr(app_txn, "boxes", []) []) boxes.append(boxreference.translate_box_reference(box_ref, app_txn.foreign_apps [], app_txn.index)) app_txn.boxes = boxes return # find available transaction resource txn_idx = _find_available_transaction_index(txns, ref_type, reference) txn_idx == -1: raise valueerror("no transactions reference limit. add another app call group.") app_txn = cast(transaction.applicationcalltxn, txns[txn_idx].txn) ref_type == "account": accounts = list(getattr(app_txn, "accounts", []) []) accounts.append(cast(str, reference)) app_txn.accounts = accounts elif ref_type == "app": app_id = int(cast(str | int, reference)) foreign_apps = list(getattr(app_txn, "foreign_apps", []) []) foreign_apps.append(app_id) app_txn.foreign_apps = foreign_apps elif ref_type == "box": boxes = list(getattr(app_txn, "boxes", []) []) boxes.append(boxreference.translate_box_reference(box_ref, app_txn.foreign_apps [], app_txn.index)) app_txn.boxes = boxes box_ref[0] != 0: foreign_apps = list(getattr(app_txn, "foreign_apps", []) []) foreign_apps.append(box_ref[0]) app_txn.foreign_apps = foreign_apps elif ref_type == "asset": asset_id = int(cast(str | int, reference)) foreign_assets = list(getattr(app_txn, "foreign_assets", []) []) foreign_assets.append(asset_id) app_txn.foreign_assets = foreign_assets elif ref_type == "assetholding": ref_dict = cast(dict[str, any], reference) foreign_assets = list(getattr(app_txn, "foreign_assets", []) []) foreign_assets.append(ref_dict["asset"]) app_txn.foreign_assets = foreign_assets accounts = list(getattr(app_txn, "accounts", []) []) accounts.append(ref_dict["account"]) app_txn.accounts = accounts elif ref_type == "applocal": ref_dict = cast(dict[str, any], reference) foreign_apps = list(getattr(app_txn, "foreign_apps", []) []) foreign_apps.append(ref_dict["app"]) app_txn.foreign_apps = foreign_apps accounts = list(getattr(app_txn, "accounts", []) []) accounts.append(ref_dict["account"]) app_txn.accounts = accounts # process group-level resources group_resources = unnamed_resources["group"] group_resources: # handle cross-reference resources first app_local group_resources.get("applocals", []): populate_group_resource(group, app_local, "applocal") # remove processed resources "accounts" group_resources: group_resources["accounts"] = [ acc acc group_resources["accounts"] acc != app_local["account"] ] "apps" group_resources: group_resources["apps"] = [app app group_resources["apps"] int(app) != int(app_local["app"])] asset_holding group_resources.get("assetholdings", []): populate_group_resource(group, asset_holding, "assetholding") # remove processed resources "accounts" group_resources: group_resources["accounts"] = [ acc acc group_resources["accounts"] acc != asset_holding["account"] ] "assets" group_resources: group_resources["assets"] = [ asset asset group_resources["assets"] int(asset) != int(asset_holding["asset"]) ] # handle remaining resources account group_resources.get("accounts", []): populate_group_resource(group, account, "account") box group_resources.get("boxes", []): populate_group_resource(group, box, "box") "apps" group_resources: group_resources["apps"] = [app app group_resources["apps"] int(app) != int(box.app_index)] asset group_resources.get("assets", []): populate_group_resource(group, asset, "asset") app group_resources.get("apps", []): populate_group_resource(group, app, "app") # handle extra box references extra_box_refs = group_resources.get("extra-box-refs", 0) _ range(extra_box_refs): populate_group_resource(group, {"app": 0, "name": ""}, "box") # create new atc updated transactions new_atc = atomictransactioncomposer() txn_with_signer group: txn_with_signer.txn.group = none new_atc.add_transaction(txn_with_signer) # copy method calls new_atc.method_dict = deepcopy(atc.method_dict) return new_atc def get_unnamed_app_call_resources_accessed(atc: atomictransactioncomposer, algod: algodclient) -&gt; dict[str, any]: """get unnamed resources accessed application calls atomic transaction group.""" # create simulation request required flags simulate_request = simulaterequest(txn_groups=[], allow_unnamed_resources=true, allow_empty_signatures=true) # create empty signer null_signer = emptysigner() # clone atc replace signers unsigned_txn_groups = atc.build_group() txn_group = [ simulaterequesttransactiongroup( txns=null_signer.sign_transactions([txn_group.txn txn_group unsigned_txn_groups], []) ) ] simulate_request = simulaterequest(txn_groups=txn_group, allow_unnamed_resources=true, allow_empty_signatures=true) # run simulation result = atc.simulate(algod, simulate_request) # get first group response group_response = result.simulate_response["txn-groups"][0] # check simulation failure group_response.get("failure-message"): failed_at = group_response.get("failed-at", [0])[0] raise atomictransactioncomposererror( f"error resource population simulation transaction {failed_at}: " f"{group_response['failure-message']}" ) # return resources accessed group transaction level return { "group": group_response.get("unnamed-resources-accessed", {}), "txns": [txn.get("unnamed-resources-accessed", {}) txn group_response.get("txn-results", [])], } max_lease_length = 32 def encode_lease(lease: str | bytes | none) -&gt; bytes | none: lease none: return none elif isinstance(lease, bytes): (1 &lt;= len(lease) &lt;= max_lease_length): raise valueerror( f"received invalid lease; expected something length 1 {max_lease_length}, " f"but received bytes length {len(lease)}" ) len(lease) == max_lease_length: return lease lease32 = bytearray(32) lease32[: len(lease)] = lease return bytes(lease32) elif isinstance(lease, str): encoded = lease.encode("utf-8") (1 &lt;= len(encoded) &lt;= max_lease_length): raise valueerror( f"received invalid lease; expected something length 1 {max_lease_length}, " f"but received '{lease}' length {len(lease)}" ) lease32 = bytearray(max_lease_length) lease32[: len(encoded)] = encoded return bytes(lease32) else: raise typeerror(f"unknown lease type received {type(lease)}")</file><file name="transactions/transaction_creator.py">collections.abc import callable typing import typevar algosdk.transaction import transaction algokit_utils.transactions.transaction_composer import ( appcallmethodcallparams, appcallparams, appcreatemethodcallparams, appcreateparams, appdeletemethodcallparams, appdeleteparams, appupdatemethodcallparams, appupdateparams, assetconfigparams, assetcreateparams, assetdestroyparams, assetfreezeparams, assetoptinparams, assetoptoutparams, assettransferparams, builttransactions, offlinekeyregistrationparams, onlinekeyregistrationparams, paymentparams, transactioncomposer, ) __all__ = [ "algorandclienttransactioncreator", ] txnparam = typevar("txnparam") txnresult = typevar("txnresult") class algorandclienttransactioncreator: """a creator algorand transactions.""" def __init__(self, new_group: callable[[], transactioncomposer]) -&gt; none: """ creates new `algorandclienttransactioncreator`. args: new_group: lambda starts new `transactioncomposer` transaction group """ self._new_group = new_group def _transaction( self, c: callable[[transactioncomposer], callable[[txnparam], transactioncomposer]] ) -&gt; callable[[txnparam], transaction]: """generic method create single transaction.""" def create_transaction(params: txnparam) -&gt; transaction: composer = self._new_group() result = c(composer)(params).build_transactions() return result.transactions[-1] return create_transaction def _transactions( self, c: callable[[transactioncomposer], callable[[txnparam], transactioncomposer]] ) -&gt; callable[[txnparam], builttransactions]: """generic method create multiple transactions.""" def create_transactions(params: txnparam) -&gt; builttransactions: composer = self._new_group() return c(composer)(params).build_transactions() return create_transactions @property def payment(self) -&gt; callable[[paymentparams], transaction]: """create payment transaction transfer algo accounts.""" return self._transaction(lambda c: c.add_payment) @property def asset_create(self) -&gt; callable[[assetcreateparams], transaction]: """create create algorand standard asset transaction.""" return self._transaction(lambda c: c.add_asset_create) @property def asset_config(self) -&gt; callable[[assetconfigparams], transaction]: """create asset config transaction reconfigure existing algorand standard asset.""" return self._transaction(lambda c: c.add_asset_config) @property def asset_freeze(self) -&gt; callable[[assetfreezeparams], transaction]: """create algorand standard asset freeze transaction.""" return self._transaction(lambda c: c.add_asset_freeze) @property def asset_destroy(self) -&gt; callable[[assetdestroyparams], transaction]: """create algorand standard asset destroy transaction.""" return self._transaction(lambda c: c.add_asset_destroy) @property def asset_transfer(self) -&gt; callable[[assettransferparams], transaction]: """create algorand standard asset transfer transaction.""" return self._transaction(lambda c: c.add_asset_transfer) @property def asset_opt_in(self) -&gt; callable[[assetoptinparams], transaction]: """create algorand standard asset opt-in transaction.""" return self._transaction(lambda c: c.add_asset_opt_in) @property def asset_opt_out(self) -&gt; callable[[assetoptoutparams], transaction]: """create asset opt-out transaction.""" return self._transaction(lambda c: c.add_asset_opt_out) @property def app_create(self) -&gt; callable[[appcreateparams], transaction]: """create application create transaction.""" return self._transaction(lambda c: c.add_app_create) @property def app_update(self) -&gt; callable[[appupdateparams], transaction]: """create application update transaction.""" return self._transaction(lambda c: c.add_app_update) @property def app_delete(self) -&gt; callable[[appdeleteparams], transaction]: """create application delete transaction.""" return self._transaction(lambda c: c.add_app_delete) @property def app_call(self) -&gt; callable[[appcallparams], transaction]: """create application call transaction.""" return self._transaction(lambda c: c.add_app_call) @property def app_create_method_call(self) -&gt; callable[[appcreatemethodcallparams], builttransactions]: """create application create call abi method call transaction.""" return self._transactions(lambda c: c.add_app_create_method_call) @property def app_update_method_call(self) -&gt; callable[[appupdatemethodcallparams], builttransactions]: """create application update call abi method call transaction.""" return self._transactions(lambda c: c.add_app_update_method_call) @property def app_delete_method_call(self) -&gt; callable[[appdeletemethodcallparams], builttransactions]: """create application delete call abi method call transaction.""" return self._transactions(lambda c: c.add_app_delete_method_call) @property def app_call_method_call(self) -&gt; callable[[appcallmethodcallparams], builttransactions]: """create application call abi method call transaction.""" return self._transactions(lambda c: c.add_app_call_method_call) @property def online_key_registration(self) -&gt; callable[[onlinekeyregistrationparams], transaction]: """create online key registration transaction.""" return self._transaction(lambda c: c.add_online_key_registration) @property def offline_key_registration(self) -&gt; callable[[offlinekeyregistrationparams], transaction]: """create offline key registration transaction.""" return self._transaction(lambda c: c.add_offline_key_registration)</file><file name="transactions/transaction_sender.py">collections.abc import callable dataclasses import dataclass typing import any, typevar import algosdk import algosdk.atomic_transaction_composer algosdk.transaction import transaction typing_extensions import self algokit_utils.applications.abi import abireturn algokit_utils.applications.app_manager import appmanager algokit_utils.assets.asset_manager import assetmanager algokit_utils.config import config algokit_utils.models.transaction import transactionwrapper algokit_utils.transactions.transaction_composer import ( appcallmethodcallparams, appcallparams, appcreatemethodcallparams, appcreateparams, appdeletemethodcallparams, appdeleteparams, appupdatemethodcallparams, appupdateparams, assetconfigparams, assetcreateparams, assetdestroyparams, assetfreezeparams, assetoptinparams, assetoptoutparams, assettransferparams, offlinekeyregistrationparams, onlinekeyregistrationparams, paymentparams, sendatomictransactioncomposerresults, transactioncomposer, txnparams, ) __all__ = [ "algorandclienttransactionsender", "sendappcreatetransactionresult", "sendapptransactionresult", "sendappupdatetransactionresult", "sendsingleassetcreatetransactionresult", "sendsingletransactionresult", ] logger = config.logger = typevar("t", bound=txnparams) @dataclass(frozen=true, kw_only=true) class sendsingletransactionresult: transaction: transactionwrapper # last transaction confirmation: algosdk.v2client.algod.algodresponsetype # last confirmation # fields sendatomictransactioncomposerresults group_id: str tx_id: str | none = none tx_ids: list[str] # full array transaction ids transactions: list[transactionwrapper] confirmations: list[algosdk.v2client.algod.algodresponsetype] returns: list[abireturn] | none = none @classmethod def from_composer_result(cls, result: sendatomictransactioncomposerresults, index: int = -1) -&gt; self: # get base parameters base_params = { "transaction": result.transactions[index], "confirmation": result.confirmations[index], "group_id": result.group_id, "tx_id": result.tx_ids[index], "tx_ids": result.tx_ids, "transactions": [result.transactions[index]], "confirmations": result.confirmations, "returns": result.returns, } # asset creation, extract asset_id confirmation cls sendsingleassetcreatetransactionresult: base_params["asset_id"] = result.confirmations[index]["asset-index"] # type: ignore[call-overload] # app creation, extract app_id calculate app_address elif cls sendappcreatetransactionresult: app_id = result.confirmations[index]["application-index"] # type: ignore[call-overload] base_params.update( { "app_id": app_id, "app_address": algosdk.logic.get_application_address(app_id), "abi_return": result.returns[index] result.returns else none, # type: ignore[dict-item] } ) # regular app transactions, add abi_return elif cls sendapptransactionresult: base_params["abi_return"] = result.returns[index] result.returns else none # type: ignore[assignment] return cls(**base_params) # type: ignore[arg-type] @dataclass(frozen=true, kw_only=true) class sendsingleassetcreatetransactionresult(sendsingletransactionresult): asset_id: int @dataclass(frozen=true) class sendapptransactionresult(sendsingletransactionresult): abi_return: abireturn | none = none @dataclass(frozen=true) class sendappupdatetransactionresult(sendapptransactionresult): compiled_approval: | none = none compiled_clear: | none = none @dataclass(frozen=true, kw_only=true) class sendappcreatetransactionresult(sendappupdatetransactionresult): app_id: int app_address: str class algorandclienttransactionsender: """orchestrates sending transactions algorandclient.""" def __init__( self, new_group: callable[[], transactioncomposer], asset_manager: assetmanager, app_manager: appmanager, algod_client: algosdk.v2client.algod.algodclient, ) -&gt; none: self._new_group = new_group self._asset_manager = asset_manager self._app_manager = app_manager self._algod = algod_client def new_group(self) -&gt; transactioncomposer: return self._new_group() def _send( self, c: callable[[transactioncomposer], callable[[t], transactioncomposer]], pre_log: callable[[t, transaction], str] | none = none, post_log: callable[[t, sendsingletransactionresult], str] | none = none, ) -&gt; callable[[t], sendsingletransactionresult]: def send_transaction(params: t) -&gt; sendsingletransactionresult: composer = self.new_group() c(composer)(params) pre_log: transaction = composer.build().transactions[-1].txn logger.debug(pre_log(params, transaction)) raw_result = composer.send( populate_app_call_resources=params.populate_app_call_resources, max_rounds_to_wait=params.max_rounds_to_wait, suppress_log=params.suppress_log, ) raw_result_dict = raw_result.__dict__.copy() raw_result_dict["transactions"] = raw_result.transactions del raw_result_dict["simulate_response"] result = sendsingletransactionresult( **raw_result_dict, confirmation=raw_result.confirmations[-1], transaction=raw_result_dict["transactions"][-1], tx_id=raw_result.tx_ids[-1], ) post_log: logger.debug(post_log(params, result)) return result return send_transaction def _send_app_call( self, c: callable[[transactioncomposer], callable[[t], transactioncomposer]], pre_log: callable[[t, transaction], str] | none = none, post_log: callable[[t, sendsingletransactionresult], str] | none = none, ) -&gt; callable[[t], sendapptransactionresult]: def send_app_call(params: t) -&gt; sendapptransactionresult: result = self._send(c, pre_log, post_log)(params) return sendapptransactionresult( **result.__dict__, abi_return=appmanager.get_abi_return(result.confirmation, getattr(params, "method", none)), ) return send_app_call def _send_app_update_call( self, c: callable[[transactioncomposer], callable[[t], transactioncomposer]], pre_log: callable[[t, transaction], str] | none = none, post_log: callable[[t, sendsingletransactionresult], str] | none = none, ) -&gt; callable[[t], sendappupdatetransactionresult]: def send_app_update_call(params: t) -&gt; sendappupdatetransactionresult: result = self._send_app_call(c, pre_log, post_log)(params) isinstance( params, appcreateparams | appupdateparams | appcreatemethodcallparams | appupdatemethodcallparams ): raise typeerror("invalid parameter type") compiled_approval = ( self._app_manager.get_compilation_result(params.approval_program) isinstance(params.approval_program, str) else none ) compiled_clear = ( self._app_manager.get_compilation_result(params.clear_state_program) isinstance(params.clear_state_program, str) else none ) return sendappupdatetransactionresult( **result.__dict__, compiled_approval=compiled_approval, compiled_clear=compiled_clear, ) return send_app_update_call def _send_app_create_call( self, c: callable[[transactioncomposer], callable[[t], transactioncomposer]], pre_log: callable[[t, transaction], str] | none = none, post_log: callable[[t, sendsingletransactionresult], str] | none = none, ) -&gt; callable[[t], sendappcreatetransactionresult]: def send_app_create_call(params: t) -&gt; sendappcreatetransactionresult: result = self._send_app_update_call(c, pre_log, post_log)(params) app_id = int(result.confirmation["application-index"]) # type: ignore[call-overload] return sendappcreatetransactionresult( **result.__dict__, app_id=app_id, app_address=algosdk.logic.get_application_address(app_id), ) return send_app_create_call def _get_method_call_for_log(self, method: algosdk.abi.method, args: list[any]) -&gt; str: """helper function format method call logs similar typescript version""" args_str = str([str(a) isinstance(a, bytes | bytearray) else a.hex() args]) return f"{method.name}({args_str})" def payment(self, params: paymentparams) -&gt; sendsingletransactionresult: """send payment transaction transfer algo accounts.""" return self._send( lambda c: c.add_payment, pre_log=lambda params, transaction: ( f"sending {params.amount} {params.sender} {params.receiver} " f"via transaction {transaction.get_txid()}" ), )(params) def asset_create(self, params: assetcreateparams) -&gt; sendsingleassetcreatetransactionresult: """create new algorand standard asset.""" result = self._send( lambda c: c.add_asset_create, post_log=lambda params, result: ( f"created asset{f' {params.asset_name}' hasattr(params, 'asset_name') else ''}" f"{f' ({params.unit_name})' hasattr(params, 'unit_name') else ''} " f"{params.total} units {getattr(params, 'decimals', 0)} decimals created " f"{params.sender} id {result.confirmation['asset-index']} via transaction " # type: ignore[call-overload] f"{result.tx_ids[-1]}" ), )(params) return sendsingleassetcreatetransactionresult( **result.__dict__, asset_id=int(result.confirmation["asset-index"]), # type: ignore[call-overload] ) def asset_config(self, params: assetconfigparams) -&gt; sendsingletransactionresult: """configure existing algorand standard asset.""" return self._send( lambda c: c.add_asset_config, pre_log=lambda params, transaction: ( f"configuring asset id {params.asset_id} via transaction {transaction.get_txid()}" ), )(params) def asset_freeze(self, params: assetfreezeparams) -&gt; sendsingletransactionresult: """freeze unfreeze algorand standard asset account.""" return self._send( lambda c: c.add_asset_freeze, pre_log=lambda params, transaction: ( f"freezing asset id {params.asset_id} via transaction {transaction.get_txid()}" ), )(params) def asset_destroy(self, params: assetdestroyparams) -&gt; sendsingletransactionresult: """destroys algorand standard asset.""" return self._send( lambda c: c.add_asset_destroy, pre_log=lambda params, transaction: ( f"destroying asset id {params.asset_id} via transaction {transaction.get_txid()}" ), )(params) def asset_transfer(self, params: assettransferparams) -&gt; sendsingletransactionresult: """transfer algorand standard asset.""" return self._send( lambda c: c.add_asset_transfer, pre_log=lambda params, transaction: ( f"transferring {params.amount} units asset id {params.asset_id} " f"{params.sender} {params.receiver} via transaction {transaction.get_txid()}" ), )(params) def asset_opt_in(self, params: assetoptinparams) -&gt; sendsingletransactionresult: """opt account algorand standard asset.""" return self._send( lambda c: c.add_asset_opt_in, pre_log=lambda params, transaction: ( f"opting {params.sender} asset id {params.asset_id} via transaction " f"{transaction.get_txid()}" ), )(params) def asset_opt_out( self, *, params: assetoptoutparams, ensure_zero_balance: bool = true, ) -&gt; sendsingletransactionresult: """opt account algorand standard asset.""" ensure_zero_balance: try: account_asset_info = self._asset_manager.get_account_information(params.sender, params.asset_id) balance = account_asset_info.balance balance != 0: raise valueerror( f"account {params.sender} zero balance asset " f"{params.asset_id}; can't opt-out." ) except exception e: raise valueerror( f"account {params.sender} opted-in asset {params.asset_id}; " "can't opt-out." ) e hasattr(params, "creator"): asset_info = self._asset_manager.get_by_id(params.asset_id) params = assetoptoutparams( **params.__dict__, creator=asset_info.creator, ) creator = params.__dict__.get("creator") return self._send( lambda c: c.add_asset_opt_out, pre_log=lambda params, transaction: ( f"opting {params.sender} asset id {params.asset_id} creator " f"{creator} via transaction {transaction.get_txid()}" ), )(params) def app_create(self, params: appcreateparams) -&gt; sendappcreatetransactionresult: """create new application.""" return self._send_app_create_call(lambda c: c.add_app_create)(params) def app_update(self, params: appupdateparams) -&gt; sendappupdatetransactionresult: """update application.""" return self._send_app_update_call(lambda c: c.add_app_update)(params) def app_delete(self, params: appdeleteparams) -&gt; sendapptransactionresult: """delete application.""" return self._send_app_call(lambda c: c.add_app_delete)(params) def app_call(self, params: appcallparams) -&gt; sendapptransactionresult: """call application.""" return self._send_app_call(lambda c: c.add_app_call)(params) def app_create_method_call(self, params: appcreatemethodcallparams) -&gt; sendappcreatetransactionresult: """call application's create method.""" return self._send_app_create_call(lambda c: c.add_app_create_method_call)(params) def app_update_method_call(self, params: appupdatemethodcallparams) -&gt; sendappupdatetransactionresult: """call application's update method.""" return self._send_app_update_call(lambda c: c.add_app_update_method_call)(params) def app_delete_method_call(self, params: appdeletemethodcallparams) -&gt; sendapptransactionresult: """call application's delete method.""" return self._send_app_call(lambda c: c.add_app_delete_method_call)(params) def app_call_method_call(self, params: appcallmethodcallparams) -&gt; sendapptransactionresult: """call application's call method.""" return self._send_app_call(lambda c: c.add_app_call_method_call)(params) def online_key_registration(self, params: onlinekeyregistrationparams) -&gt; sendsingletransactionresult: """register online key.""" return self._send( lambda c: c.add_online_key_registration, pre_log=lambda params, transaction: ( f"registering online key {params.sender} via transaction {transaction.get_txid()}" ), )(params) def offline_key_registration(self, params: offlinekeyregistrationparams) -&gt; sendsingletransactionresult: """register offline key.""" return self._send( lambda c: c.add_offline_key_registration, pre_log=lambda params, transaction: ( f"registering offline key {params.sender} via transaction {transaction.get_txid()}" ), )(params)</file><file name="accounts/kmd_account_manager.py">collections.abc import callable typing import any, cast algosdk.kmd import kmdclient algokit_utils.clients.client_manager import clientmanager algokit_utils.config import config algokit_utils.models.account import account algokit_utils.models.amount import algoamount algokit_utils.transactions.transaction_composer import paymentparams, transactioncomposer __all__ = ["kmdaccount", "kmdaccountmanager"] logger = config.logger class kmdaccount(account): """account retrieved kmd signing capabilities, extending base account""" def __init__(self, private_key: str, address: str | none = none) -&gt; none: """initialize kmd account private key optional address override args: private_key: base64 encoded private key address: optional address override (for rekeyed accounts) """ super().__init__(private_key=private_key, address=address "") class kmdaccountmanager: """provides abstractions kmd makes easier get manage accounts.""" _kmd: kmdclient | none def __init__(self, client_manager: clientmanager) -&gt; none: """create new kmd manager. args: client_manager: clientmanager use account management """ self._client_manager = client_manager try: self._kmd = client_manager.kmd except valueerror: self._kmd = none def kmd(self) -&gt; kmdclient: """get kmd client, initializing needed. returns: kmdclient: initialized kmd client raises: exception: kmd configured """ self._kmd none: self._client_manager.is_localnet(): kmd_config = clientmanager.get_config_from_environment_or_localnet() self._kmd = clientmanager.get_kmd_client(kmd_config.kmd_config) return self._kmd raise exception("attempt use kmd client kmd configured") return self._kmd def get_wallet_account( self, wallet_name: str, predicate: callable[[dict[str, any]], bool] | none = none, sender: str | none = none, ) -&gt; kmdaccount | none: """returns algorand signing account private key loaded given kmd wallet. args: wallet_name: name wallet retrieve account predicate: optional filter use find account (otherwise returns random account wallet) sender: optional sender address use signer (aka rekeyed account) returns: optional[kmdaccount]: signing account none matching wallet account found example: ```python # get default funded account localnet default_dispenser = kmd_manager.get_wallet_account( "unencrypted-default-wallet", lambda a: a["status"] != "offline" a["amount"] &gt; 1_000_000_000 ) ``` """ kmd_client = self.kmd() wallets = kmd_client.list_wallets() wallet = next((w w wallets w["name"] == wallet_name), none) wallet: return none wallet_id = wallet["id"] wallet_handle = kmd_client.init_wallet_handle(wallet_id, "") addresses = kmd_client.list_keys(wallet_handle) matched_address = none predicate: address addresses: account_info = self._client_manager.algod.account_info(address) predicate(cast(dict[str, any], account_info)): matched_address = address break else: matched_address = next(iter(addresses), none) matched_address: return none private_key = kmd_client.export_key(wallet_handle, "", matched_address) return kmdaccount(private_key=private_key, address=sender) def get_or_create_wallet_account(self, name: str, fund_with: algoamount | none = none) -&gt; kmdaccount: """gets creates funded account kmd wallet given name. useful get idempotent accounts localnet without specify private key (which change resetting localnet). args: name: name wallet retrieve / create fund_with: number algos fund account created (default: 1000) returns: kmdaccount: algorand account private key loaded example: ```python # idempotently get (if exists) create (if exist) account name using kmd # creating fund 2 algo default dispenser account new_account = kmd_manager.get_or_create_wallet_account("account1", 2) # return account since name matches existing_account = kmd_manager.get_or_create_wallet_account("account1") ``` """ existing = self.get_wallet_account(name) existing: return existing kmd_client = self.kmd() wallet_id = kmd_client.create_wallet(name, "")["id"] wallet_handle = kmd_client.init_wallet_handle(wallet_id, "") kmd_client.generate_key(wallet_handle) account = self.get_wallet_account(name) assert account none logger.info( f"localnet account '{name}' yet exist; created account {account.address} " f"with keys stored kmd funding {fund_with} algo" ) dispenser = self.get_localnet_dispenser_account() transactioncomposer( algod=self._client_manager.algod, get_signer=lambda _: dispenser.signer, get_suggested_params=self._client_manager.algod.suggested_params, ).add_payment( paymentparams( sender=dispenser.address, receiver=account.address, amount=fund_with algoamount.from_algo(1000), ) ).send() return account def get_localnet_dispenser_account(self) -&gt; kmdaccount: """returns algorand account private key loaded default localnet dispenser account. returns: kmdaccount: default localnet dispenser account raises: exception: running localnet dispenser account found example: ```python dispenser = kmd_manager.get_localnet_dispenser_account() ``` """ self._client_manager.is_localnet(): raise exception("can't get localnet dispenser account non localnet network") dispenser = self.get_wallet_account( "unencrypted-default-wallet", lambda a: a["status"] != "offline" a["amount"] &gt; 1_000_000_000, # noqa: plr2004 ) dispenser: raise exception("error retrieving localnet dispenser account; find default account kmd") return dispenser</file><file name="accounts/__init__.py">algokit_utils.accounts.account_manager import * # noqa: f403 algokit_utils.accounts.kmd_account_manager import * # noqa: f403</file><file name="accounts/account_manager.py">import os collections.abc import callable dataclasses import dataclass typing import algosdk import mnemonic algosdk.atomic_transaction_composer import logicsigtransactionsigner, transactionsigner algosdk.mnemonic import to_private_key algosdk.transaction import logicsigaccount, suggestedparams typing_extensions import self algokit_utils.accounts.kmd_account_manager import kmdaccountmanager algokit_utils.clients.client_manager import clientmanager algokit_utils.clients.dispenser_api_client import dispenserassetname, testnetdispenserapiclient algokit_utils.config import config algokit_utils.models.account import dispenser_account_name, account, multisigaccount, multisigmetadata algokit_utils.models.amount import algoamount algokit_utils.transactions.transaction_composer import ( paymentparams, sendatomictransactioncomposerresults, transactioncomposer, ) algokit_utils.transactions.transaction_sender import sendsingletransactionresult logger = config.logger __all__ = [ "accountinformation", "accountmanager", "ensurefundedfromtestnetdispenserapiresponse", "ensurefundedresponse", ] @dataclass(frozen=true, kw_only=true) class _commonensurefundedparams: """ common parameters ensure funded responses. """ transaction_id: str amount_funded: algoamount @dataclass(frozen=true, kw_only=true) class ensurefundedresponse(sendsingletransactionresult, _commonensurefundedparams): """ response performing ensure funded call. """ @dataclass(frozen=true, kw_only=true) class ensurefundedfromtestnetdispenserapiresponse(_commonensurefundedparams): """ response performing ensure funded call using testnet dispenser api. """ @dataclass(frozen=true, kw_only=true) class accountinformation: """ information algorand account's current status, balance properties. see `https://developer.algorand.org/docs/rest-apis/algod/#account` detailed field descriptions. :param str address: account's address :param int amount: account's current balance microalgos :param int amount_without_pending_rewards: account's balance microalgos without pending rewards :param int min_balance: account's minimum required balance microalgos :param int pending_rewards: amount pending rewards microalgos :param int rewards: amount rewards earned microalgos :param int round: round information relevant :param str status: account's status (e.g., 'offline', 'online') :param int|none total_apps_opted_in: number applications account opted :param int|none total_assets_opted_in: number assets account opted :param int|none total_box_bytes: total number box bytes used account :param int|none total_boxes: total number boxes used account :param int|none total_created_apps: number applications created account :param int|none total_created_assets: number assets created account :param list[dict]|none apps_local_state: local state applications account opted :param int|none apps_total_extra_pages: number extra pages allocated applications :param dict|none apps_total_schema: total schema applications :param list[dict]|none assets: assets held account :param str|none auth_addr: rekeyed, authorized address :param int|none closed_at_round: round account closed :param list[dict]|none created_apps: applications created account :param list[dict]|none created_assets: assets created account :param int|none created_at_round: round account created :param bool|none deleted: whether account deleted :param bool|none incentive_eligible: whether account eligible incentives :param int|none last_heartbeat: last heartbeat round account :param int|none last_proposed: last round account proposed block :param dict|none participation: participation information account :param int|none reward_base: base reward account :param str|none sig_type: signature type account """ address: str amount: int amount_without_pending_rewards: int min_balance: int pending_rewards: int rewards: int round: int status: str total_apps_opted_in: int | none = none total_assets_opted_in: int | none = none total_box_bytes: int | none = none total_boxes: int | none = none total_created_apps: int | none = none total_created_assets: int | none = none apps_local_state: list[dict] | none = none apps_total_extra_pages: int | none = none apps_total_schema: dict | none = none assets: list[dict] | none = none auth_addr: str | none = none closed_at_round: int | none = none created_apps: list[dict] | none = none created_assets: list[dict] | none = none created_at_round: int | none = none deleted: bool | none = none incentive_eligible: bool | none = none last_heartbeat: int | none = none last_proposed: int | none = none participation: dict | none = none reward_base: int | none = none sig_type: str | none = none class accountmanager: """ creates keeps track signing accounts sign transactions sending address. class provides functionality create, track, manage various types accounts including mnemonic-based, rekeyed, multisig, logic signature accounts. """ def __init__(self, client_manager: clientmanager): """ create new account manager. :param clientmanager client_manager: clientmanager client use algod kmd clients :example: &gt;&gt;&gt; account_manager = accountmanager(client_manager) """ self._client_manager = client_manager self._kmd_account_manager = kmdaccountmanager(client_manager) self._signers = dict[str, transactionsigner]() self._default_signer: transactionsigner | none = none def set_default_signer(self, signer: transactionsigner) -&gt; self: """ sets default signer use signer specified. set transaction needs signing given sender error thrown `get_signer` / `get_account`. :param transactionsigner signer: `transactionsigner` signer use. :returns: `accountmanager` method calls chained :example: &gt;&gt;&gt; signer_account = account_manager.random() &gt;&gt;&gt; account_manager.set_default_signer(signer_account.signer) &gt;&gt;&gt; # signing transaction, signer registered sender &gt;&gt;&gt; # default signer used &gt;&gt;&gt; signer = account_manager.get_signer("{senderaddress}") """ self._default_signer = signer return self def set_signer(self, sender: str, signer: transactionsigner) -&gt; self: """ tracks given `transactionsigner` given sender address later signing. :param str sender: sender address use signer :param transactionsigner signer: `transactionsigner` sign transactions given sender :returns: `accountmanager` instance method chaining :example: &gt;&gt;&gt; account_manager.set_signer("senderaddress", transaction_signer) """ self._signers[sender] = signer return self def set_signer_from_account(self, account: account | logicsigaccount | multisigaccount) -&gt; self: """ tracks given account later signing. note: generating accounts via various methods `accountmanager` (like `random`, `from_mnemonic`, `logic_sig`, etc.) automatically get tracked. :param account|logicsigaccount|multisigaccount account: account register :returns: `accountmanager` instance method chaining :example: &gt;&gt;&gt; account_manager = accountmanager(client_manager) &gt;&gt;&gt; account_manager.set_signer_from_account(account.new_account()) &gt;&gt;&gt; account_manager.set_signer_from_account(logicsigaccount(program, args)) &gt;&gt;&gt; account_manager.set_signer_from_account(multisigaccount(multisig_params, [account1, account2])) """ isinstance(account, logicsigaccount): addr = account.address() self._signers[addr] = logicsigtransactionsigner(account) else: addr = account.address self._signers[addr] = account.signer return self def get_signer(self, sender: str | account | logicsigaccount) -&gt; transactionsigner: """ returns `transactionsigner` given sender address. signer registered address default signer used registered. :param str|account|logicsigaccount sender: sender address account :returns: `transactionsigner` :raises valueerror: signer found default signer set :example: &gt;&gt;&gt; signer = account_manager.get_signer("senderaddress") """ signer = self._signers.get(self._get_address(sender)) self._default_signer signer: raise valueerror(f"no signer found address {sender}") return signer def get_account(self, sender: str) -&gt; account: """ returns `account` given sender address. :param str sender: sender address :returns: `account` :raises valueerror: account found account regular account :example: &gt;&gt;&gt; sender = account_manager.random() &gt;&gt;&gt; # ... &gt;&gt;&gt; # returns `account` `sender` previously registered &gt;&gt;&gt; account = account_manager.get_account(sender) """ account = self._signers.get(sender) account: raise valueerror(f"no account found address {sender}") isinstance(account, account): raise valueerror(f"account {sender} regular account") return account def get_logic_sig_account(self, sender: str) -&gt; logicsigaccount: """ returns `logicsigaccount` given sender address. :param str sender: sender address :returns: `logicsigaccount` :raises valueerror: account found account logic signature account """ account = self._signers.get(sender) account: raise valueerror(f"no account found address {sender}") isinstance(account, logicsigaccount): raise valueerror(f"account {sender} logic sig account") return account def get_information(self, sender: str | account) -&gt; accountinformation: """ returns given sender account's current status, balance spendable amounts. see `&lt;https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress&gt;`_ response data schema details. :param str|account sender: address sender/account look :returns: account information :example: &gt;&gt;&gt; address = "xbyls2e6yi6xxl5bwcamoa4gtwhxwenzmx5uhxmrnwwuq7bxcy5wc5tepa" &gt;&gt;&gt; account_info = account_manager.get_information(address) """ info = self._client_manager.algod.account_info(self._get_address(sender)) assert isinstance(info, dict) info = {k.replace("-", "_"): v k, v info.items()} return accountinformation(**info) def _register_account(self, private_key: str) -&gt; account: """ helper method create register account signer. :param str private_key: private key account :returns: registered account instance """ account = account(private_key=private_key) self._signers[account.address] = account.signer return account def _register_logic_sig(self, program: bytes, args: list[bytes] | none = none) -&gt; logicsigaccount: """ helper method create register logic signature account. :param bytes program: bytes make compiled logic signature :param list[bytes]|none args: (binary) arguments pass logic signature :returns: registered logicsigaccount instance """ logic_sig = logicsigaccount(program, args) self._signers[logic_sig.address()] = logicsigtransactionsigner(logic_sig) return logic_sig def _register_multi_sig( self, version: int, threshold: int, addrs: list[str], signing_accounts: list[account] ) -&gt; multisigaccount: """ helper method create register multisig account. :param int version: version multisig account :param int threshold: threshold number signatures required :param list[str] addrs: list addresses sign :param list[account] signing_accounts: list accounts present sign :returns: registered multisigaccount instance """ msig_account = multisigaccount( multisigmetadata(version=version, threshold=threshold, addresses=addrs), signing_accounts, ) self._signers[str(msig_account.address)] = msig_account.signer return msig_account def from_mnemonic(self, mnemonic: str) -&gt; account: """ tracks returns algorand account secret key loaded taking mnemonic secret. :param str mnemonic: mnemonic secret representing private key account :returns: account .. warning:: careful mnemonic handled. never commit source control ideally load environment (ideally via secret storage service) rather file system. :example: &gt;&gt;&gt; account = account_manager.from_mnemonic("mnemonic secret ...") """ private_key = to_private_key(mnemonic) return self._register_account(private_key) def from_environment(self, name: str, fund_with: algoamount | none = none) -&gt; account: """ tracks returns algorand account private key loaded convention environment variables. allows write code work seamlessly production local development (localnet) without manual config locally (including reset localnet). :param str name: name identifier account :param algoamount|none fund_with: optional amount fund account gets created (when targeting localnet) :returns: account :raises valueerror: environment variable {name}_mnemonic missing looking account {name} .. note:: convention: * **non-localnet:** load `{name}_mnemonic` mnemonic secret. `{name}_sender` defined use sender address (i.e. support rekeyed accounts) * **localnet:** load account kmd wallet called {name} wallet exist create fund account :example: &gt;&gt;&gt; # mnemonic secret loaded `my_account_mnemonic` call: &gt;&gt;&gt; account = account_manager.from_environment('my_account') &gt;&gt;&gt; # code runs localnet wallet called `my_account` automatically created &gt;&gt;&gt; # account automatically funded specified amount default localnet dispenser """ account_mnemonic = os.getenv(f"{name.upper()}_mnemonic") account_mnemonic: private_key = mnemonic.to_private_key(account_mnemonic) return self._register_account(private_key) self._client_manager.is_localnet(): kmd_account = self._kmd_account_manager.get_or_create_wallet_account(name, fund_with) return self._register_account(kmd_account.private_key) raise valueerror(f"missing environment variable {name.upper()}_mnemonic looking account {name}") def from_kmd( self, name: str, predicate: callable[[dict[str, any]], bool] | none = none, sender: str | none = none ) -&gt; account: """ tracks returns algorand account private key loaded given kmd wallet. :param str name: name wallet retrieve account :param callable[[dict[str, any]], bool]|none predicate: optional filter use find account :param str|none sender: optional sender address use signer (aka rekeyed account) :returns: account :raises valueerror: unable find kmd account given name predicate :example: &gt;&gt;&gt; # get default funded account localnet: &gt;&gt;&gt; defaultdispenseraccount = account.from_kmd('unencrypted-default-wallet', ... lambda a: a.status != 'offline' a.amount &gt; 1_000_000_000 ... ) """ kmd_account = self._kmd_account_manager.get_wallet_account(name, predicate, sender) kmd_account: raise valueerror(f"unable find kmd account {name}{' predicate' predicate else ''}") return self._register_account(kmd_account.private_key) def logic_sig(self, program: bytes, args: list[bytes] | none = none) -&gt; logicsigaccount: """ tracks returns account represents logic signature. :param bytes program: bytes make compiled logic signature :param list[bytes]|none args: optional (binary) arguments pass logic signature :returns: logic signature account wrapper :example: &gt;&gt;&gt; account = account.logic_sig(program, [new uint8array(3, ...)]) """ return self._register_logic_sig(program, args) def multi_sig( self, version: int, threshold: int, addrs: list[str], signing_accounts: list[account] ) -&gt; multisigaccount: """ tracks returns account supports partial full multisig signing. :param int version: version multisig account :param int threshold: threshold number signatures required :param list[str] addrs: list addresses sign :param list[account] signing_accounts: signers currently present :returns: multisig account wrapper :example: &gt;&gt;&gt; account = account_manager.multi_sig( ... version=1, ... threshold=1, ... addrs=["address1...", "address2..."], ... signing_accounts=[account1, account2] ... ) """ return self._register_multi_sig(version, threshold, addrs, signing_accounts) def random(self) -&gt; account: """ tracks returns new, random algorand account. :returns: account :example: &gt;&gt;&gt; account = account_manager.random() """ account = account.new_account() return self._register_account(account.private_key) def localnet_dispenser(self) -&gt; account: """ returns algorand account private key loaded default localnet dispenser account. account used fund accounts. :returns: account :example: &gt;&gt;&gt; account = account_manager.localnet_dispenser() """ kmd_account = self._kmd_account_manager.get_localnet_dispenser_account() return self._register_account(kmd_account.private_key) def dispenser_from_environment(self) -&gt; account: """ returns account (with private key loaded) act dispenser environment variables. environment variables present, returns default localnet dispenser account. :returns: account :example: &gt;&gt;&gt; account = account_manager.dispenser_from_environment() """ name = os.getenv(f"{dispenser_account_name}_mnemonic") name: return self.from_environment(dispenser_account_name) return self.localnet_dispenser() def rekeyed(self, sender: account | str, account: account) -&gt; account: """ tracks returns algorand account rekeyed version given account new sender. :param account|str sender: account address use sender :param account account: account use signer new rekeyed account :returns: rekeyed account :example: &gt;&gt;&gt; account = account.from_mnemonic("mnemonic secret ...") &gt;&gt;&gt; rekeyed_account = account_manager.rekeyed(account, "senderaddress...") """ sender_address = sender.address isinstance(sender, account) else sender self._signers[sender_address] = account.signer return account(address=sender_address, private_key=account.private_key) def rekey_account( # noqa: plr0913 self, account: str | account, rekey_to: str | account, *, # common transaction parameters signer: transactionsigner | none = none, note: bytes | none = none, lease: bytes | none = none, static_fee: algoamount | none = none, extra_fee: algoamount | none = none, max_fee: algoamount | none = none, validity_window: int | none = none, first_valid_round: int | none = none, last_valid_round: int | none = none, suppress_log: bool | none = none, ) -&gt; sendatomictransactioncomposerresults: """ rekey account new address. :param str|account account: account rekey :param str|account rekey_to: address account rekey :param transactionsigner|none signer: optional transaction signer :param bytes|none note: optional transaction note :param bytes|none lease: optional transaction lease :param algoamount|none static_fee: optional static fee :param algoamount|none extra_fee: optional extra fee :param algoamount|none max_fee: optional max fee :param int|none validity_window: optional validity window :param int|none first_valid_round: optional first valid round :param int|none last_valid_round: optional last valid round :param bool|none suppress_log: optional flag suppress logging :returns: result transaction transaction sent .. warning:: please careful function sure read `official rekey guidance &lt;https://developer.algorand.org/docs/get-details/accounts/rekey/&gt;`_. :example: &gt;&gt;&gt; # basic example (with string addresses): &gt;&gt;&gt; algorand.account.rekey_account({account: "accountaddress", rekey_to: "newaddress"}) &gt;&gt;&gt; # basic example (with signer accounts): &gt;&gt;&gt; algorand.account.rekey_account({account: account1, rekey_to: newsigneraccount}) &gt;&gt;&gt; # advanced example: &gt;&gt;&gt; algorand.account.rekey_account({ ... account: "accountaddress", ... rekey_to: "newaddress", ... lease: 'lease', ... note: 'note', ... first_valid_round: 1000, ... validity_window: 10, ... extra_fee: algoamount.from_micro_algo(1000), ... static_fee: algoamount.from_micro_algo(1000), ... max_fee: algoamount.from_micro_algo(3000), ... suppress_log: true, ... }) """ sender_address = self._get_address(account) rekey_address = self._get_address(rekey_to) result = ( self._get_composer() .add_payment( paymentparams( sender=sender_address, receiver=sender_address, amount=algoamount.from_micro_algo(0), rekey_to=rekey_address, signer=signer, note=note, lease=lease, static_fee=static_fee, extra_fee=extra_fee, max_fee=max_fee, validity_window=validity_window, first_valid_round=first_valid_round, last_valid_round=last_valid_round, suppress_log=suppress_log, ) ) .send() ) # rekey_to signing account, set signer account isinstance(rekey_to, account): self.rekeyed(account, rekey_to) suppress_log: logger.info(f"rekeyed {sender_address} {rekey_address} via transaction {result.tx_ids[-1]}") return result def ensure_funded( # noqa: plr0913 self, account_to_fund: str | account, dispenser_account: str | account, min_spending_balance: algoamount, min_funding_increment: algoamount | none = none, # sender params max_rounds_to_wait: int | none = none, suppress_log: bool | none = none, populate_app_call_resources: bool | none = none, # common txn params signer: transactionsigner | none = none, rekey_to: str | none = none, note: bytes | none = none, lease: bytes | none = none, static_fee: algoamount | none = none, extra_fee: algoamount | none = none, max_fee: algoamount | none = none, validity_window: int | none = none, first_valid_round: int | none = none, last_valid_round: int | none = none, ) -&gt; ensurefundedresponse | none: """ funds given account using dispenser account funding source. ensures given account certain amount algo free spend (accounting algo locked minimum balance requirement). see `&lt;https://developer.algorand.org/docs/get-details/accounts/#minimum-balance&gt;`_ details. :param str|account account_to_fund: account fund :param str|account dispenser_account: account use dispenser funding source :param algoamount min_spending_balance: minimum balance algo account available spend :param algoamount|none min_funding_increment: optional minimum funding increment :param int|none max_rounds_to_wait: optional maximum rounds wait transaction :param bool|none suppress_log: optional flag suppress logging :param bool|none populate_app_call_resources: optional flag populate app call resources :param transactionsigner|none signer: optional transaction signer :param str|none rekey_to: optional rekey address :param bytes|none note: optional transaction note :param bytes|none lease: optional transaction lease :param algoamount|none static_fee: optional static fee :param algoamount|none extra_fee: optional extra fee :param algoamount|none max_fee: optional maximum fee :param int|none validity_window: optional validity window :param int|none first_valid_round: optional first valid round :param int|none last_valid_round: optional last valid round :returns: result executing dispensing transaction `amountfunded` funds needed, none funds needed :example: &gt;&gt;&gt; # basic example: &gt;&gt;&gt; algorand.account.ensure_funded("accountaddress", "dispenseraddress", algokit.algo(1)) &gt;&gt;&gt; # configuration: &gt;&gt;&gt; algorand.account.ensure_funded( ... "accountaddress", ... "dispenseraddress", ... algokit.algo(1), ... min_funding_increment=algokit.algo(2), ... fee=algoamount.from_micro_algo(1000), ... suppress_log=true ... ) """ account_to_fund = self._get_address(account_to_fund) dispenser_account = self._get_address(dispenser_account) amount_funded = self._get_ensure_funded_amount(account_to_fund, min_spending_balance, min_funding_increment) amount_funded: return none result = ( self._get_composer() .add_payment( paymentparams( sender=dispenser_account, receiver=account_to_fund, amount=amount_funded, signer=signer, rekey_to=rekey_to, note=note, lease=lease, static_fee=static_fee, extra_fee=extra_fee, max_fee=max_fee, validity_window=validity_window, first_valid_round=first_valid_round, last_valid_round=last_valid_round, ) ) .send( max_rounds_to_wait=max_rounds_to_wait, suppress_log=suppress_log, populate_app_call_resources=populate_app_call_resources, ) ) return ensurefundedresponse( returns=result.returns, transactions=result.transactions, confirmations=result.confirmations, tx_ids=result.tx_ids, group_id=result.group_id, transaction_id=result.tx_ids[0], confirmation=result.confirmations[0], transaction=result.transactions[0], amount_funded=amount_funded, ) def ensure_funded_from_environment( # noqa: plr0913 self, account_to_fund: str | account, min_spending_balance: algoamount, *, # force remaining params keyword-only min_funding_increment: algoamount | none = none, # sendparams max_rounds_to_wait: int | none = none, suppress_log: bool | none = none, populate_app_call_resources: bool | none = none, # common transaction params (omitting sender) signer: transactionsigner | none = none, rekey_to: str | none = none, note: bytes | none = none, lease: bytes | none = none, static_fee: algoamount | none = none, extra_fee: algoamount | none = none, max_fee: algoamount | none = none, validity_window: int | none = none, first_valid_round: int | none = none, last_valid_round: int | none = none, ) -&gt; ensurefundedresponse | none: """ ensure account funded dispenser account configured environment. uses dispenser account retrieved environment, per `dispenser_from_environment` method, funding source given account certain amount algo free spend (accounting algo locked minimum balance requirement). see `&lt;https://developer.algorand.org/docs/get-details/accounts/#minimum-balance&gt;`_ details. :param str|account account_to_fund: account fund :param algoamount min_spending_balance: minimum balance algo account available spend :param algoamount|none min_funding_increment: optional minimum funding increment :param int|none max_rounds_to_wait: optional maximum rounds wait transaction :param bool|none suppress_log: optional flag suppress logging :param bool|none populate_app_call_resources: optional flag populate app call resources :param transactionsigner|none signer: optional transaction signer :param str|none rekey_to: optional rekey address :param bytes|none note: optional transaction note :param bytes|none lease: optional transaction lease :param algoamount|none static_fee: optional static fee :param algoamount|none extra_fee: optional extra fee :param algoamount|none max_fee: optional maximum fee :param int|none validity_window: optional validity window :param int|none first_valid_round: optional first valid round :param int|none last_valid_round: optional last valid round :returns: result executing dispensing transaction `amountfunded` funds needed, none funds needed .. note:: dispenser account retrieved account mnemonic stored process.env.dispenser_mnemonic optionally process.env.dispenser_sender rekeyed account, default localnet environment variables present. :example: &gt;&gt;&gt; # basic example: &gt;&gt;&gt; algorand.account.ensure_funded_from_environment("accountaddress", algokit.algo(1)) &gt;&gt;&gt; # configuration: &gt;&gt;&gt; algorand.account.ensure_funded_from_environment( ... "accountaddress", ... algokit.algo(1), ... min_funding_increment=algokit.algo(2), ... fee=algoamount.from_micro_algo(1000), ... suppress_log=true ... ) """ account_to_fund = self._get_address(account_to_fund) dispenser_account = self.dispenser_from_environment() amount_funded = self._get_ensure_funded_amount(account_to_fund, min_spending_balance, min_funding_increment) amount_funded: return none result = ( self._get_composer() .add_payment( paymentparams( sender=dispenser_account.address, receiver=account_to_fund, amount=amount_funded, signer=signer, rekey_to=rekey_to, note=note, lease=lease, static_fee=static_fee, extra_fee=extra_fee, max_fee=max_fee, validity_window=validity_window, first_valid_round=first_valid_round, last_valid_round=last_valid_round, ) ) .send( max_rounds_to_wait=max_rounds_to_wait, suppress_log=suppress_log, populate_app_call_resources=populate_app_call_resources, ) ) return ensurefundedresponse( returns=result.returns, transactions=result.transactions, confirmations=result.confirmations, tx_ids=result.tx_ids, group_id=result.group_id, transaction_id=result.tx_ids[0], confirmation=result.confirmations[0], transaction=result.transactions[0], amount_funded=amount_funded, ) def ensure_funded_from_testnet_dispenser_api( self, account_to_fund: str | account, dispenser_client: testnetdispenserapiclient, min_spending_balance: algoamount, *, # force remaining params keyword-only min_funding_increment: algoamount | none = none, ) -&gt; ensurefundedfromtestnetdispenserapiresponse | none: """ ensure account funded using testnet dispenser api. uses testnet dispenser api funding source account certain amount algo free spend (accounting algo locked minimum balance requirement). see `&lt;https://developer.algorand.org/docs/get-details/accounts/#minimum-balance&gt;`_ details. :param str|account account_to_fund: account fund :param testnetdispenserapiclient dispenser_client: testnet dispenser funding client :param algoamount min_spending_balance: minimum balance algo account available spend :param algoamount|none min_funding_increment: optional minimum funding increment :returns: result executing dispensing transaction `amountfunded` funds needed, none funds needed :raises valueerror: attempting fund non-testnet network :example: &gt;&gt;&gt; # basic example: &gt;&gt;&gt; algorand.account.ensure_funded_from_testnet_dispenser_api( ... "accountaddress", ... algorand.client.get_testnet_dispenser_from_environment(), ... algokit.algo(1) ... ) &gt;&gt;&gt; # configuration: &gt;&gt;&gt; algorand.account.ensure_funded_from_testnet_dispenser_api( ... "accountaddress", ... algorand.client.get_testnet_dispenser_from_environment(), ... algokit.algo(1), ... min_funding_increment=algokit.algo(2) ... ) """ account_to_fund = self._get_address(account_to_fund) self._client_manager.is_testnet(): raise valueerror("attempt fund using testnet dispenser api non testnet network.") amount_funded = self._get_ensure_funded_amount(account_to_fund, min_spending_balance, min_funding_increment) amount_funded: return none result = dispenser_client.fund( address=account_to_fund, amount=amount_funded.micro_algo, asset_id=dispenserassetname.algo, ) return ensurefundedfromtestnetdispenserapiresponse( transaction_id=result.tx_id, amount_funded=algoamount.from_micro_algo(result.amount), ) def _get_address(self, sender: str | account | logicsigaccount) -&gt; str: match sender: case account(): return sender.address case logicsigaccount(): return sender.address() case str(): return sender case _: raise valueerror(f"unknown sender type: {type(sender)}") def _get_composer(self, get_suggested_params: callable[[], suggestedparams] | none = none) -&gt; transactioncomposer: get_suggested_params none: def _get_suggested_params() -&gt; suggestedparams: return self._client_manager.algod.suggested_params() get_suggested_params = _get_suggested_params return transactioncomposer( algod=self._client_manager.algod, get_signer=self.get_signer, get_suggested_params=get_suggested_params ) def _calculate_fund_amount( self, min_spending_balance: int, current_spending_balance: int, min_funding_increment: int, ) -&gt; int | none: min_spending_balance &gt; current_spending_balance: min_fund_amount = min_spending_balance - current_spending_balance return max(min_fund_amount, min_funding_increment) return none def _get_ensure_funded_amount( self, sender: str, min_spending_balance: algoamount, min_funding_increment: algoamount | none = none, ) -&gt; algoamount | none: account_info = self.get_information(sender) current_spending_balance = account_info.amount - account_info.min_balance min_increment = min_funding_increment.micro_algo min_funding_increment else 0 amount_funded = self._calculate_fund_amount( min_spending_balance.micro_algo, current_spending_balance, min_increment ) return algoamount.from_micro_algo(amount_funded) amount_funded none else none</file><file name="applications/app_factory.py">import base64 collections.abc import callable dataclasses import asdict, dataclass, replace typing import any, typevar algosdk import transaction algosdk.abi import method algosdk.atomic_transaction_composer import transactionsigner algosdk.source_map import sourcemap algosdk.transaction import oncomplete, transaction typing_extensions import self algokit_utils._legacy_v2.application_specification import applicationspecification algokit_utils.applications.abi import ( abireturn, abistruct, abivalue, arc56returnvaluetype, get_abi_decoded_value, get_abi_tuple_from_abi_struct, ) algokit_utils.applications.app_client import ( appclient, appclientbarecallparams, appclientcompilationparams, appclientcompilationresult, appclientmethodcallparams, appclientparams, ) algokit_utils.applications.app_deployer import ( appdeploymetadata, appdeployparams, appdeployresponse, applookup, appmetadata, onschemabreak, onupdate, operationperformed, ) algokit_utils.applications.app_manager import deletable_template_name, updatable_template_name algokit_utils.applications.app_spec.arc56 import arc56contract algokit_utils.models.application import ( appsourcemaps, ) algokit_utils.models.state import tealtemplateparams algokit_utils.models.transaction import sendparams algokit_utils.protocols.client import algorandclientprotocol algokit_utils.transactions.transaction_composer import ( appcreatemethodcallparams, appcreateparams, appdeletemethodcallparams, appdeleteparams, appupdatemethodcallparams, appupdateparams, builttransactions, ) algokit_utils.transactions.transaction_sender import ( sendappcreatetransactionresult, sendapptransactionresult, sendappupdatetransactionresult, sendsingletransactionresult, ) = typevar("t") __all__ = [ "appfactory", "appfactorycreatemethodcallparams", "appfactorycreatemethodcallresult", "appfactorycreatemethodcallwithsendparams", "appfactorycreateparams", "appfactorycreatewithsendparams", "appfactorydeployresponse", "appfactoryparams", "sendappcreatefactorytransactionresult", "sendappfactorytransactionresult", "sendappupdatefactorytransactionresult", ] @dataclass(kw_only=true, frozen=true) class appfactoryparams: algorand: algorandclientprotocol app_spec: arc56contract | applicationspecification | str app_name: str | none = none default_sender: str | bytes | none = none default_signer: transactionsigner | none = none version: str | none = none updatable: bool | none = none deletable: bool | none = none deploy_time_params: tealtemplateparams | none = none @dataclass(kw_only=true, frozen=true) class appfactorycreateparams(appclientbarecallparams, appclientcompilationparams): on_complete: transaction.oncomplete | none = none schema: dict[str, int] | none = none extra_program_pages: int | none = none @dataclass(kw_only=true, frozen=true) class appfactorycreatewithsendparams(appfactorycreateparams, sendparams): pass @dataclass(kw_only=true, frozen=true) class appfactorycreatemethodcallparams(appclientmethodcallparams, appclientcompilationparams): on_complete: transaction.oncomplete | none = none schema: dict[str, int] | none = none extra_program_pages: int | none = none @dataclass(frozen=true, kw_only=true) class appfactorycreatemethodcallresult(sendsingletransactionresult): app_id: int app_address: str compiled_approval: | none = none compiled_clear: | none = none abi_return: abivalue | abistruct | none = none @dataclass(kw_only=true, frozen=true) class appfactorycreatemethodcallwithsendparams(appfactorycreatemethodcallparams, sendparams): pass @dataclass(frozen=true) class sendappfactorytransactionresult(sendapptransactionresult): abi_value: arc56returnvaluetype | none = none @dataclass(frozen=true) class sendappupdatefactorytransactionresult(sendappupdatetransactionresult): abi_value: arc56returnvaluetype | none = none @dataclass(frozen=true, kw_only=true) class sendappcreatefactorytransactionresult(sendappcreatetransactionresult): abi_value: arc56returnvaluetype | none = none @dataclass(frozen=true) class appfactorydeployresponse: """result deploying application via appfactory""" app: appmetadata operation_performed: operationperformed create_response: sendappcreatefactorytransactionresult | none = none update_response: sendappupdatefactorytransactionresult | none = none delete_response: sendappfactorytransactionresult | none = none @classmethod def from_deploy_response( cls, response: appdeployresponse, deploy_params: appdeployparams, app_spec: arc56contract, app_compilation_data: appclientcompilationresult | none = none, ) -&gt; self: def to_factory_response( response_data: sendapptransactionresult | sendappcreatetransactionresult | sendappupdatetransactionresult | none, params: any, # noqa: ann401 ) -&gt; | none: # noqa: ann401 response_data: return none abi_value = none abi_return = response_data.abi_return abi_return abi_return.method: abi_value = abi_return.get_arc56_value(params.method, app_spec.structs) match response_data: case sendappcreatetransactionresult(): return sendappcreatefactorytransactionresult(**asdict(response_data), abi_value=abi_value) case sendappupdatetransactionresult(): raw_response = asdict(response_data) raw_response["compiled_approval"] = ( app_compilation_data.compiled_approval app_compilation_data else none ) raw_response["compiled_clear"] = ( app_compilation_data.compiled_clear app_compilation_data else none ) return sendappupdatefactorytransactionresult(**raw_response, abi_value=abi_value) case sendapptransactionresult(): return sendappfactorytransactionresult(**asdict(response_data), abi_value=abi_value) return cls( app=response.app, operation_performed=response.operation_performed, create_response=to_factory_response( response.create_response, deploy_params.create_params, ), update_response=to_factory_response( response.update_response, deploy_params.update_params, ), delete_response=to_factory_response( response.delete_response, deploy_params.delete_params, ), ) class _appfactorybareparamsaccessor: def __init__(self, factory: "appfactory") -&gt; none: self._factory = factory self._algorand = factory._algorand def create(self, params: appfactorycreateparams | none = none) -&gt; appcreateparams: base_params = params appfactorycreateparams() compiled = self._factory.compile(base_params) return appcreateparams( approval_program=compiled.approval_program, clear_state_program=compiled.clear_state_program, schema=base_params.schema { "global_bytes": self._factory._app_spec.state.schema.global_state.bytes, "global_ints": self._factory._app_spec.state.schema.global_state.ints, "local_bytes": self._factory._app_spec.state.schema.local_state.bytes, "local_ints": self._factory._app_spec.state.schema.local_state.ints, }, sender=self._factory._get_sender(base_params.sender), signer=self._factory._get_signer(base_params.sender, base_params.signer), on_complete=base_params.on_complete oncomplete.noopoc, extra_program_pages=base_params.extra_program_pages, ) def deploy_update(self, params: appclientbarecallparams | none = none) -&gt; appupdateparams: return appupdateparams( app_id=0, approval_program="", clear_state_program="", sender=self._factory._get_sender(params.sender params else none), on_complete=oncomplete.updateapplicationoc, signer=self._factory._get_signer(params.sender params else none, params.signer params else none), note=params.note params else none, lease=params.lease params else none, rekey_to=params.rekey_to params else none, account_references=params.account_references params else none, app_references=params.app_references params else none, asset_references=params.asset_references params else none, box_references=params.box_references params else none, ) def deploy_delete(self, params: appclientbarecallparams | none = none) -&gt; appdeleteparams: return appdeleteparams( app_id=0, sender=self._factory._get_sender(params.sender params else none), signer=self._factory._get_signer(params.sender params else none, params.signer params else none), on_complete=oncomplete.deleteapplicationoc, note=params.note params else none, lease=params.lease params else none, rekey_to=params.rekey_to params else none, account_references=params.account_references params else none, app_references=params.app_references params else none, asset_references=params.asset_references params else none, box_references=params.box_references params else none, ) class _appfactoryparamsaccessor: def __init__(self, factory: "appfactory") -&gt; none: self._factory = factory self._bare = _appfactorybareparamsaccessor(factory) @property def bare(self) -&gt; _appfactorybareparamsaccessor: return self._bare def create(self, params: appfactorycreatemethodcallparams) -&gt; appcreatemethodcallparams: compiled = self._factory.compile(params) return appcreatemethodcallparams( app_id=0, approval_program=compiled.approval_program, clear_state_program=compiled.clear_state_program, schema=params.schema { "global_bytes": self._factory._app_spec.state.schema.global_state.bytes, "global_ints": self._factory._app_spec.state.schema.global_state.ints, "local_bytes": self._factory._app_spec.state.schema.local_state.bytes, "local_ints": self._factory._app_spec.state.schema.local_state.ints, }, sender=self._factory._get_sender(params.sender), signer=self._factory._get_signer(params.sender params else none, params.signer params else none), method=self._factory._app_spec.get_arc56_method(params.method).to_abi_method(), args=self._factory._get_create_abi_args_with_default_values(params.method, params.args), on_complete=params.on_complete oncomplete.noopoc, note=params.note, lease=params.lease, rekey_to=params.rekey_to, ) def deploy_update(self, params: appclientmethodcallparams) -&gt; appupdatemethodcallparams: return appupdatemethodcallparams( app_id=0, approval_program="", clear_state_program="", sender=self._factory._get_sender(params.sender), signer=self._factory._get_signer(params.sender params else none, params.signer params else none), method=self._factory._app_spec.get_arc56_method(params.method).to_abi_method(), args=self._factory._get_create_abi_args_with_default_values(params.method, params.args), on_complete=oncomplete.updateapplicationoc, note=params.note, lease=params.lease, rekey_to=params.rekey_to, ) def deploy_delete(self, params: appclientmethodcallparams) -&gt; appdeletemethodcallparams: return appdeletemethodcallparams( app_id=0, sender=self._factory._get_sender(params.sender), signer=self._factory._get_signer(params.sender params else none, params.signer params else none), method=self._factory.app_spec.get_arc56_method(params.method).to_abi_method(), args=self._factory._get_create_abi_args_with_default_values(params.method, params.args), on_complete=oncomplete.deleteapplicationoc, note=params.note, lease=params.lease, rekey_to=params.rekey_to, ) class _appfactorybarecreatetransactionaccessor: def __init__(self, factory: "appfactory") -&gt; none: self._factory = factory def create(self, params: appfactorycreateparams | none = none) -&gt; transaction: return self._factory._algorand.create_transaction.app_create(self._factory.params.bare.create(params)) class _appfactorycreatetransactionaccessor: def __init__(self, factory: "appfactory") -&gt; none: self._factory = factory self._bare = _appfactorybarecreatetransactionaccessor(factory) @property def bare(self) -&gt; _appfactorybarecreatetransactionaccessor: return self._bare def create(self, params: appfactorycreatemethodcallparams) -&gt; builttransactions: return self._factory._algorand.create_transaction.app_create_method_call(self._factory.params.create(params)) class _appfactorybaresendaccessor: def __init__(self, factory: "appfactory") -&gt; none: self._factory = factory self._algorand = factory._algorand def create( self, params: appfactorycreatewithsendparams | none = none ) -&gt; tuple[appclient, sendappcreatetransactionresult]: base_params = params appfactorycreatewithsendparams() # use replace() create new instance overridden values create_params = replace( base_params, updatable=base_params.updatable base_params.updatable none else self._factory._updatable, deletable=base_params.deletable base_params.deletable none else self._factory._deletable, deploy_time_params=( base_params.deploy_time_params base_params.deploy_time_params none else self._factory._deploy_time_params ), ) compiled = self._factory.compile( appclientcompilationparams( deploy_time_params=create_params.deploy_time_params, updatable=create_params.updatable, deletable=create_params.deletable, ) ) result = self._factory._handle_call_errors( lambda: self._algorand.send.app_create(self._factory.params.bare.create(create_params)) ) return ( self._factory.get_app_client_by_id( app_id=result.app_id, ), sendappcreatetransactionresult( transaction=result.transaction, confirmation=result.confirmation, app_id=result.app_id, app_address=result.app_address, compiled_approval=compiled.compiled_approval compiled else none, compiled_clear=compiled.compiled_clear compiled else none, group_id=result.group_id, tx_ids=result.tx_ids, transactions=result.transactions, confirmations=result.confirmations, ), ) class _appfactorysendaccessor: def __init__(self, factory: "appfactory") -&gt; none: self._factory = factory self._algorand = factory._algorand self._bare = _appfactorybaresendaccessor(factory) @property def bare(self) -&gt; _appfactorybaresendaccessor: return self._bare def create(self, params: appfactorycreatemethodcallparams) -&gt; tuple[appclient, appfactorycreatemethodcallresult]: create_params = replace( params, updatable=params.updatable params.updatable none else self._factory._updatable, deletable=params.deletable params.deletable none else self._factory._deletable, deploy_time_params=( params.deploy_time_params params.deploy_time_params none else self._factory._deploy_time_params ), ) compiled = self._factory.compile( appclientcompilationparams( deploy_time_params=create_params.deploy_time_params, updatable=create_params.updatable, deletable=create_params.deletable, ) ) result = self._factory._handle_call_errors( lambda: self._factory._parse_method_call_return( lambda: self._algorand.send.app_create_method_call(self._factory.params.create(create_params)), self._factory._app_spec.get_arc56_method(params.method).to_abi_method(), ) ) return ( self._factory.get_app_client_by_id( app_id=result.app_id, ), appfactorycreatemethodcallresult( transaction=result.transaction, confirmation=result.confirmation, tx_id=result.tx_id, app_id=result.app_id, app_address=result.app_address, abi_return=result.abi_return, compiled_approval=compiled.compiled_approval compiled else none, compiled_clear=compiled.compiled_clear compiled else none, group_id=result.group_id, tx_ids=result.tx_ids, transactions=result.transactions, confirmations=result.confirmations, returns=result.returns, ), ) class appfactory: def __init__(self, params: appfactoryparams) -&gt; none: self._app_spec = appclient.normalise_app_spec(params.app_spec) self._app_name = params.app_name self._app_spec.name self._algorand = params.algorand self._version = params.version "1.0" self._default_sender = params.default_sender self._default_signer = params.default_signer self._deploy_time_params = params.deploy_time_params self._updatable = params.updatable self._deletable = params.deletable self._approval_source_map: sourcemap | none = none self._clear_source_map: sourcemap | none = none self._params_accessor = _appfactoryparamsaccessor(self) self._send_accessor = _appfactorysendaccessor(self) self._create_transaction_accessor = _appfactorycreatetransactionaccessor(self) @property def app_name(self) -&gt; str: return self._app_name @property def app_spec(self) -&gt; arc56contract: return self._app_spec @property def algorand(self) -&gt; algorandclientprotocol: return self._algorand @property def params(self) -&gt; _appfactoryparamsaccessor: return self._params_accessor @property def send(self) -&gt; _appfactorysendaccessor: return self._send_accessor @property def create_transaction(self) -&gt; _appfactorycreatetransactionaccessor: return self._create_transaction_accessor def deploy( # noqa: plr0913 self, *, deploy_time_params: tealtemplateparams | none = none, on_update: onupdate = onupdate.fail, on_schema_break: onschemabreak = onschemabreak.fail, create_params: appclientmethodcallparams | appclientbarecallparams | none = none, update_params: appclientmethodcallparams | appclientbarecallparams | none = none, delete_params: appclientmethodcallparams | appclientbarecallparams | none = none, existing_deployments: applookup | none = none, ignore_cache: bool = false, updatable: bool | none = none, deletable: bool | none = none, app_name: str | none = none, max_rounds_to_wait: int | none = none, suppress_log: bool = false, populate_app_call_resources: bool = false, ) -&gt; tuple[appclient, appfactorydeployresponse]: """deploy application specified parameters.""" # resolve control parameters factory defaults resolved_updatable = ( updatable updatable none else self._updatable self._get_deploy_time_control("updatable") ) resolved_deletable = ( deletable deletable none else self._deletable self._get_deploy_time_control("deletable") ) resolved_deploy_time_params = deploy_time_params self._deploy_time_params def prepare_create_args() -&gt; appcreatemethodcallparams | appcreateparams: """prepare create arguments based parameter type.""" create_params isinstance(create_params, appclientmethodcallparams): return self.params.create( appfactorycreatemethodcallparams( **asdict(create_params), updatable=resolved_updatable, deletable=resolved_deletable, deploy_time_params=resolved_deploy_time_params, ) ) base_params = create_params appclientbarecallparams() return self.params.bare.create( appfactorycreateparams( **asdict(base_params) base_params else {}, updatable=resolved_updatable, deletable=resolved_deletable, deploy_time_params=resolved_deploy_time_params, ) ) def prepare_update_args() -&gt; appupdatemethodcallparams | appupdateparams: """prepare update arguments based parameter type.""" return ( self.params.deploy_update(update_params) isinstance(update_params, appclientmethodcallparams) else self.params.bare.deploy_update(update_params) ) def prepare_delete_args() -&gt; appdeletemethodcallparams | appdeleteparams: """prepare delete arguments based parameter type.""" return ( self.params.deploy_delete(delete_params) isinstance(delete_params, appclientmethodcallparams) else self.params.bare.deploy_delete(delete_params) ) # execute deployment deploy_params = appdeployparams( deploy_time_params=resolved_deploy_time_params, on_schema_break=on_schema_break, on_update=on_update, existing_deployments=existing_deployments, ignore_cache=ignore_cache, create_params=prepare_create_args(), update_params=prepare_update_args(), delete_params=prepare_delete_args(), metadata=appdeploymetadata( name=app_name self._app_name, version=self._version, updatable=resolved_updatable, deletable=resolved_deletable, ), suppress_log=suppress_log, max_rounds_to_wait=max_rounds_to_wait, populate_app_call_resources=populate_app_call_resources, ) deploy_response = self._algorand.app_deployer.deploy(deploy_params) # prepare app client factory deploy response app_client = self.get_app_client_by_id( app_id=deploy_response.app.app_id, app_name=app_name, default_sender=self._default_sender, default_signer=self._default_signer, ) factory_deploy_response = appfactorydeployresponse.from_deploy_response( response=deploy_response, deploy_params=deploy_params, app_spec=app_client.app_spec, app_compilation_data=self.compile( appclientcompilationparams( deploy_time_params=resolved_deploy_time_params, updatable=resolved_updatable, deletable=resolved_deletable, ) ), ) return app_client, factory_deploy_response def get_app_client_by_id( self, app_id: int, app_name: str | none = none, default_sender: str | bytes | none = none, # address string bytes default_signer: transactionsigner | none = none, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, ) -&gt; appclient: return appclient( appclientparams( app_id=app_id, algorand=self._algorand, app_spec=self._app_spec, app_name=app_name self._app_name, default_sender=default_sender self._default_sender, default_signer=default_signer self._default_signer, approval_source_map=approval_source_map self._approval_source_map, clear_source_map=clear_source_map self._clear_source_map, ) ) def get_app_client_by_creator_and_name( self, creator_address: str, app_name: str, default_sender: str | bytes | none = none, default_signer: transactionsigner | none = none, ignore_cache: bool | none = none, app_lookup_cache: applookup | none = none, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, ) -&gt; appclient: return appclient.from_creator_and_name( creator_address=creator_address, app_name=app_name self._app_name, default_sender=default_sender self._default_sender, default_signer=default_signer self._default_signer, approval_source_map=approval_source_map self._approval_source_map, clear_source_map=clear_source_map self._clear_source_map, ignore_cache=ignore_cache, app_lookup_cache=app_lookup_cache, app_spec=self._app_spec, algorand=self._algorand, ) def export_source_maps(self) -&gt; appsourcemaps: self._approval_source_map self._clear_source_map: raise valueerror( "unable export source maps; loaded client - " "you need call create, update, deploy first" ) return appsourcemaps( approval_source_map=self._approval_source_map, clear_source_map=self._clear_source_map, ) def import_source_maps(self, source_maps: appsourcemaps) -&gt; none: self._approval_source_map = source_maps.approval_source_map self._clear_source_map = source_maps.clear_source_map def compile(self, compilation: appclientcompilationparams | none = none) -&gt; appclientcompilationresult: result = appclient.compile( app_spec=self._app_spec, app_manager=self._algorand.app, deploy_time_params=compilation.deploy_time_params compilation else none, updatable=compilation.updatable compilation else none, deletable=compilation.deletable compilation else none, ) result.compiled_approval: self._approval_source_map = result.compiled_approval.source_map result.compiled_clear: self._clear_source_map = result.compiled_clear.source_map return result def _expose_logic_error(self, e: exception, is_clear_state_program: bool = false) -&gt; exception: # noqa: fbt002 fbt001 return appclient._expose_logic_error_static( e=e, app_spec=self._app_spec, is_clear_state_program=is_clear_state_program, approval_source_map=self._approval_source_map, clear_source_map=self._clear_source_map, program=none, approval_source_info=(self._app_spec.source_info.approval self._app_spec.source_info else none), clear_source_info=(self._app_spec.source_info.clear self._app_spec.source_info else none), ) def _get_deploy_time_control(self, control: str) -&gt; bool | none: approval = self._app_spec.source.get_decoded_approval() self._app_spec.source else none template_name = updatable_template_name control == "updatable" else deletable_template_name approval template_name approval: return none on_complete = "updateapplication" control == "updatable" else "deleteapplication" return on_complete self._app_spec.bare_actions.call any( on_complete m.actions.call self._app_spec.methods m.actions m.actions.call ) def _get_sender(self, sender: str | bytes | none) -&gt; str: sender self._default_sender: raise exception( f"no sender provided default sender present app client call app {self._app_name}" ) return str(sender self._default_sender) def _get_signer(self, sender: str | none, signer: transactionsigner | none) -&gt; transactionsigner | none: return signer (self._default_signer sender sender == self._default_sender else none) def _handle_call_errors(self, call: callable[[], t]) -&gt; t: try: return call() except exception e: raise self._expose_logic_error(e) none def _parse_method_call_return( self, result: callable[ [], sendapptransactionresult | sendappcreatetransactionresult | sendappupdatetransactionresult ], method: method, ) -&gt; appfactorycreatemethodcallresult: result_value = result() return appfactorycreatemethodcallresult( **{ **result_value.__dict__, "abi_return": result_value.abi_return.get_arc56_value(method, self._app_spec.structs) isinstance(result_value.abi_return, abireturn) else none, } ) def _get_create_abi_args_with_default_values( self, method_name_or_signature: str, user_args: list[any] | none, ) -&gt; list[any]: """ builds list abi argument values creation calls, applying default argument values provided. """ method = self._app_spec.get_arc56_method(method_name_or_signature) results: list[any] = [] i, param enumerate(method.args): user_args &lt; len(user_args): arg_value = user_args[i] param.struct isinstance(arg_value, dict): arg_value = get_abi_tuple_from_abi_struct( arg_value, self._app_spec.structs[param.struct], self._app_spec.structs, ) results.append(arg_value) continue default_value = getattr(param, "default_value", none) default_value: default_value.source == "literal": raw_value = base64.b64decode(default_value.data) value_type = default_value.type str(param.type) decoded_value = get_abi_decoded_value(raw_value, value_type, self._app_spec.structs) results.append(decoded_value) else: raise valueerror( f"cannot provide default value source={default_value.source} " "for contract creation call." ) else: param_name = param.name f"arg{i + 1}" raise valueerror( f"no value provided required argument {param_name} " f"in call method {method.name}" ) return results</file><file name="applications/__init__.py">algokit_utils.applications.app_client import * # noqa: f403 algokit_utils.applications.app_deployer import * # noqa: f403 algokit_utils.applications.app_factory import * # noqa: f403 algokit_utils.applications.app_manager import * # noqa: f403 algokit_utils.applications.app_spec import * # noqa: f403</file><file name="applications/app_client.py">__future__ import annotations import base64 import copy import json import os dataclasses import dataclass, fields typing import type_checking, any, protocol, typevar import algosdk algosdk.source_map import sourcemap algosdk.transaction import oncomplete, transaction algokit_utils._debugging import persistsourcemapinput, persist_sourcemaps algokit_utils.applications.abi import ( boxabivalue, get_abi_decoded_value, get_abi_encoded_value, get_abi_tuple_from_abi_struct, ) algokit_utils.applications.app_spec.arc32 import arc32contract algokit_utils.applications.app_spec.arc56 import ( arc56contract, pcoffsetmethod, programsourceinfo, sourceinfo, storagekey, storagemap, ) algokit_utils.config import config algokit_utils.errors.logic_error import logicerror, parse_logic_error algokit_utils.models.application import ( appsourcemaps, appstate, compiledteal, ) algokit_utils.models.state import boxname, boxvalue algokit_utils.models.transaction import sendparams algokit_utils.transactions.transaction_composer import ( appcallmethodcallparams, appcallparams, appdeletemethodcallparams, appmethodcalltransactionargument, appupdatemethodcallparams, appupdateparams, builttransactions, paymentparams, ) algokit_utils.transactions.transaction_sender import ( sendapptransactionresult, sendappupdatetransactionresult, sendsingletransactionresult, ) type_checking: collections.abc import callable algosdk.atomic_transaction_composer import transactionsigner algokit_utils.applications.abi import abistruct, abitype, abivalue algokit_utils.applications.app_deployer import applookup algokit_utils.applications.app_manager import appmanager algokit_utils.models.amount import algoamount algokit_utils.models.state import boxidentifier, boxreference, tealtemplateparams algokit_utils.protocols.client import algorandclientprotocol __all__ = [ "appclient", "appclientbarecallparams", "appclientbarecallwithcalloncompleteparams", "appclientbarecallwithcompilationandsendparams", "appclientbarecallwithcompilationparams", "appclientbarecallwithsendparams", "appclientcallparams", "appclientcompilationparams", "appclientcompilationresult", "appclientmethodcallparams", "appclientmethodcallwithcompilationandsendparams", "appclientmethodcallwithcompilationparams", "appclientmethodcallwithsendparams", "appclientparams", "appsourcemaps", "fundappaccountparams", ] # teal opcodes constant blocks byte_cblock = 38 # bytecblock opcode int_cblock = 32 # intcblock opcode = typevar("t") # generic return type _handle_call_errors def get_constant_block_offset(program: bytes) -&gt; int: # noqa: c901 """calculate offset constant blocks teal program. args: program: compiled teal program bytes returns: maximum offset bytecblock/intcblock operations """ bytes_list = list(program) program_size = len(bytes_list) # remove version byte bytes_list.pop(0) # track offsets bytecblock_offset: int | none = none intcblock_offset: int | none = none bytes_list: # get current byte byte = bytes_list.pop(0) # check byte constant block opcode byte (byte_cblock, int_cblock): is_bytecblock = byte == byte_cblock # get number values constant block bytes_list: break values_remaining = bytes_list.pop(0) # process value block _ range(values_remaining): is_bytecblock: # bytecblock, next byte length element bytes_list: break length = bytes_list.pop(0) # remove bytes element bytes_list = bytes_list[length:] else: # intcblock, read find end uvarint (msb set) bytes_list: byte = bytes_list.pop(0) (byte &amp; 0x80): # check msb set break # update appropriate offset is_bytecblock: bytecblock_offset = program_size - len(bytes_list) - 1 else: intcblock_offset = program_size - len(bytes_list) - 1 # next byte constant block opcode, we're done bytes_list bytes_list[0] (byte_cblock, int_cblock): break # return maximum offset return max(bytecblock_offset 0, intcblock_offset 0) @dataclass(kw_only=true, frozen=true) class appclientcompilationresult: approval_program: bytes clear_state_program: bytes compiled_approval: compiledteal | none = none compiled_clear: compiledteal | none = none @dataclass(kw_only=true, frozen=true) class appclientcompilationparams: deploy_time_params: tealtemplateparams | none = none updatable: bool | none = none deletable: bool | none = none @dataclass(kw_only=true) class fundappaccountparams: sender: str | none = none signer: transactionsigner | none = none rekey_to: str | none = none note: bytes | none = none lease: bytes | none = none static_fee: algoamount | none = none extra_fee: algoamount | none = none max_fee: algoamount | none = none validity_window: int | none = none first_valid_round: int | none = none last_valid_round: int | none = none amount: algoamount close_remainder_to: str | none = none max_rounds_to_wait: int | none = none suppress_log: bool | none = none populate_app_call_resources: bool | none = none on_complete: algosdk.transaction.oncomplete | none = none @dataclass(kw_only=true) class appclientcallparams: method: str | none = none # calling abi method, name signature args: list | none = none # arguments pass method boxes: list | none = none # box references load accounts: list[str] | none = none # account addresses load apps: list[int] | none = none # app ids load assets: list[int] | none = none # asset ids load lease: (str | bytes) | none = none # optional lease sender: str | none = none # optional sender account note: (bytes | dict | str) | none = none # transaction note send_params: dict | none = none # parameters control transaction sending @dataclass(kw_only=true, frozen=true) class appclientmethodcallparams: method: str args: list[abivalue | abistruct | appmethodcalltransactionargument | none] | none = none account_references: list[str] | none = none app_references: list[int] | none = none asset_references: list[int] | none = none box_references: list[boxreference | boxidentifier] | none = none extra_fee: algoamount | none = none first_valid_round: int | none = none lease: bytes | none = none max_fee: algoamount | none = none note: bytes | none = none rekey_to: str | none = none sender: str | none = none signer: transactionsigner | none = none static_fee: algoamount | none = none validity_window: int | none = none last_valid_round: int | none = none on_complete: algosdk.transaction.oncomplete | none = none @dataclass(kw_only=true, frozen=true) class appclientmethodcallwithcompilationparams(appclientmethodcallparams, appclientcompilationparams): """combined parameters method calls compilation""" @dataclass(kw_only=true, frozen=true) class appclientmethodcallwithsendparams(appclientmethodcallparams, sendparams): """combined parameters method calls send options""" @dataclass(kw_only=true, frozen=true) class appclientmethodcallwithcompilationandsendparams( appclientmethodcallparams, appclientcompilationparams, sendparams ): """combined parameters method calls compilation send options""" @dataclass(kw_only=true, frozen=true) class appclientbarecallparams: signer: transactionsigner | none = none rekey_to: str | none = none lease: bytes | none = none static_fee: algoamount | none = none extra_fee: algoamount | none = none max_fee: algoamount | none = none validity_window: int | none = none first_valid_round: int | none = none last_valid_round: int | none = none sender: str | none = none note: bytes | none = none args: list[bytes] | none = none account_references: list[str] | none = none app_references: list[int] | none = none asset_references: list[int] | none = none box_references: list[boxreference | boxidentifier] | none = none @dataclass(kw_only=true, frozen=true) class _calloncomplete: on_complete: algosdk.transaction.oncomplete @dataclass(kw_only=true, frozen=true) class appclientbarecallwithcompilationparams(appclientbarecallparams, appclientcompilationparams): """combined parameters bare calls compilation""" @dataclass(kw_only=true, frozen=true) class appclientbarecallwithsendparams(appclientbarecallparams, sendparams): """combined parameters bare calls send options""" @dataclass(kw_only=true, frozen=true) class appclientbarecallwithcompilationandsendparams(appclientbarecallparams, appclientcompilationparams, sendparams): """combined parameters bare calls compilation send options""" @dataclass(kw_only=true, frozen=true) class appclientbarecallwithcalloncompleteparams(appclientbarecallparams, _calloncomplete): """combined parameters bare calls oncomplete value""" class _appclientstatemethodsprotocol(protocol): def get_all(self) -&gt; dict[str, any]: ... def get_value(self, name: str, app_state: dict[str, appstate] | none = none) -&gt; abivalue | none: ... def get_map_value(self, map_name: str, key: bytes | any, app_state: dict[str, appstate] | none = none) -&gt; any: ... # noqa: ann401 def get_map(self, map_name: str) -&gt; dict[str, abivalue]: ... class _appclientboxmethodsprotocol(protocol): def get_all(self) -&gt; dict[str, any]: ... def get_value(self, name: str) -&gt; abivalue | none: ... def get_map_value(self, map_name: str, key: bytes | any) -&gt; any: ... # noqa: ann401 def get_map(self, map_name: str) -&gt; dict[str, abivalue]: ... class _appclientstatemethods(_appclientstatemethodsprotocol): def __init__( self, *, get_all: callable[[], dict[str, any]], get_value: callable[[str, dict[str, appstate] | none], abivalue | none], get_map_value: callable[[str, bytes | any, dict[str, appstate] | none], any], get_map: callable[[str], dict[str, abivalue]], ) -&gt; none: self._get_all = get_all self._get_value = get_value self._get_map_value = get_map_value self._get_map = get_map def get_all(self) -&gt; dict[str, any]: return self._get_all() def get_value(self, name: str, app_state: dict[str, appstate] | none = none) -&gt; abivalue | none: return self._get_value(name, app_state) def get_map_value(self, map_name: str, key: bytes | any, app_state: dict[str, appstate] | none = none) -&gt; any: # noqa: ann401 return self._get_map_value(map_name, key, app_state) def get_map(self, map_name: str) -&gt; dict[str, abivalue]: return self._get_map(map_name) class _appclientboxmethods(_appclientboxmethodsprotocol): def __init__( self, *, get_all: callable[[], dict[str, any]], get_value: callable[[str], abivalue | none], get_map_value: callable[[str, bytes | any], any], get_map: callable[[str], dict[str, abivalue]], ) -&gt; none: self._get_all = get_all self._get_value = get_value self._get_map_value = get_map_value self._get_map = get_map def get_all(self) -&gt; dict[str, any]: return self._get_all() def get_value(self, name: str) -&gt; abivalue | none: return self._get_value(name) def get_map_value(self, map_name: str, key: bytes | any) -&gt; any: # noqa: ann401 return self._get_map_value(map_name, key) def get_map(self, map_name: str) -&gt; dict[str, abivalue]: return self._get_map(map_name) class _appclientstateaccessor: def __init__(self, client: appclient) -&gt; none: self._client = client self._algorand = client._algorand self._app_id = client._app_id self._app_spec = client._app_spec def local_state(self, address: str) -&gt; _appclientstatemethodsprotocol: """methods access local state current app given address""" return self._get_state_methods( state_getter=lambda: self._algorand.app.get_local_state(self._app_id, address), key_getter=lambda: self._app_spec.state.keys.local_state, map_getter=lambda: self._app_spec.state.maps.local_state, ) @property def global_state(self) -&gt; _appclientstatemethodsprotocol: """methods access global state current app""" return self._get_state_methods( state_getter=lambda: self._algorand.app.get_global_state(self._app_id), key_getter=lambda: self._app_spec.state.keys.global_state, map_getter=lambda: self._app_spec.state.maps.global_state, ) @property def box(self) -&gt; _appclientboxmethodsprotocol: """methods access box storage current app""" return self._get_box_methods() def _get_box_methods(self) -&gt; _appclientboxmethodsprotocol: """get methods access box storage current app.""" def get_all() -&gt; dict[str, any]: """returns single-key box values dict keyed key name.""" return {key: get_value(key) key self._app_spec.state.keys.box} def get_value(name: str) -&gt; abivalue | none: """returns single box value current app value decoded abi value. args: name: name box value retrieve """ metadata = self._app_spec.state.keys.box[name] value = self._algorand.app.get_box_value(self._app_id, base64.b64decode(metadata.key)) return get_abi_decoded_value(value, metadata.value_type, self._app_spec.structs) def get_map_value(map_name: str, key: bytes | any) -&gt; any: # noqa: ann401 """get value box map. args: map_name: name map read key: key within map (without map prefix) either bytes value converted bytes encoding using specified abi key type """ metadata = self._app_spec.state.maps.box[map_name] prefix = base64.b64decode(metadata.prefix "") encoded_key = get_abi_encoded_value(key, metadata.key_type, self._app_spec.structs) full_key = base64.b64encode(prefix + encoded_key).decode("utf-8") value = self._algorand.app.get_box_value(self._app_id, base64.b64decode(full_key)) return get_abi_decoded_value(value, metadata.value_type, self._app_spec.structs) def get_map(map_name: str) -&gt; dict[str, abivalue]: """get key-value pairs box map. args: map_name: name map read """ metadata = self._app_spec.state.maps.box[map_name] prefix = base64.b64decode(metadata.prefix "") box_names = self._algorand.app.get_box_names(self._app_id) result = {} box box_names: box.name_raw.startswith(prefix): continue encoded_key = prefix + box.name_raw base64_key = base64.b64encode(encoded_key).decode("utf-8") try: key = get_abi_decoded_value(box.name_raw[len(prefix) :], metadata.key_type, self._app_spec.structs) value = get_abi_decoded_value( self._algorand.app.get_box_value(self._app_id, base64.b64decode(base64_key)), metadata.value_type, self._app_spec.structs, ) result[str(key)] = value except exception e: "failed decode key" str(e): raise valueerror(f"failed decode key {base64_key}") e raise valueerror(f"failed decode value key {base64_key}") e return result return _appclientboxmethods( get_all=get_all, get_value=get_value, get_map_value=get_map_value, get_map=get_map, ) def _get_state_methods( # noqa: c901 self, state_getter: callable[[], dict[str, appstate]], key_getter: callable[[], dict[str, storagekey]], map_getter: callable[[], dict[str, storagemap]], ) -&gt; _appclientstatemethodsprotocol: def get_all() -&gt; dict[str, any]: state = state_getter() keys = key_getter() return {key: get_value(key, state) key keys} def get_value(name: str, app_state: dict[str, appstate] | none = none) -&gt; abivalue | none: state = app_state state_getter() key_info = key_getter()[name] value = next((s state.values() s.key_base64 == key_info.key), none) value value.value_raw: return get_abi_decoded_value(value.value_raw, key_info.value_type, self._app_spec.structs) return value.value value else none def get_map_value(map_name: str, key: bytes | any, app_state: dict[str, appstate] | none = none) -&gt; any: # noqa: ann401 state = app_state state_getter() metadata = map_getter()[map_name] prefix = bytes(metadata.prefix "", "base64") encoded_key = get_abi_encoded_value(key, metadata.key_type, self._app_spec.structs) full_key = base64.b64encode(prefix + encoded_key).decode("utf-8") value = next((s state.values() s.key_base64 == full_key), none) value value.value_raw: return get_abi_decoded_value(value.value_raw, metadata.value_type, self._app_spec.structs) return value.value value else none def get_map(map_name: str) -&gt; dict[str, abivalue]: state = state_getter() metadata = map_getter()[map_name] prefix = metadata.prefix "" prefixed_state = {k: v k, v state.items() k.startswith(prefix)} decoded_map = {} key_encoded, value prefixed_state.items(): key_bytes = key_encoded[len(prefix) :] try: decoded_key = get_abi_decoded_value(key_bytes, metadata.key_type, self._app_spec.structs) except exception e: raise valueerror(f"failed decode key {key_encoded}") e try: value value.value_raw: decoded_value = get_abi_decoded_value( value.value_raw, metadata.value_type, self._app_spec.structs ) else: decoded_value = get_abi_decoded_value(value.value, metadata.value_type, self._app_spec.structs) except exception e: raise valueerror(f"failed decode value {value}") e decoded_map[str(decoded_key)] = decoded_value return decoded_map return _appclientstatemethods( get_all=get_all, get_value=get_value, get_map_value=get_map_value, get_map=get_map, ) def get_local_state(self, address: str) -&gt; dict[str, appstate]: return self._algorand.app.get_local_state(self._app_id, address) def get_global_state(self) -&gt; dict[str, appstate]: return self._algorand.app.get_global_state(self._app_id) class _appclientbareparamsaccessor: def __init__(self, client: appclient) -&gt; none: self._client = client self._algorand = client._algorand self._app_id = client._app_id self._app_spec = client._app_spec def _get_bare_params( self, params: dict[str, any] | none, on_complete: algosdk.transaction.oncomplete ) -&gt; dict[str, any]: """get bare parameters application calls. args: params: parameters process on_complete: oncomplete value transaction returns: processed parameters defaults filled """ params = params {} sender = self._client._get_sender(params.get("sender")) return { **params, "app_id": self._app_id, "sender": sender, "signer": self._client._get_signer(params.get("sender"), params.get("signer")), "on_complete": on_complete, } def update(self, params: appclientbarecallwithcompilationandsendparams | none = none) -&gt; appupdateparams: call_params: appupdateparams = appupdateparams( **self._get_bare_params(params.__dict__ params else {}, oncomplete.updateapplicationoc) ) return call_params def opt_in(self, params: appclientbarecallwithsendparams | none = none) -&gt; appcallparams: call_params: appcallparams = appcallparams(**self._get_bare_params(params.__dict__, oncomplete.optinoc)) return call_params def delete(self, params: appclientbarecallwithsendparams) -&gt; appcallparams: call_params: appcallparams = appcallparams( **self._get_bare_params(params.__dict__, oncomplete.deleteapplicationoc) ) return call_params def clear_state(self, params: appclientbarecallwithsendparams) -&gt; appcallparams: call_params: appcallparams = appcallparams(**self._get_bare_params(params.__dict__, oncomplete.clearstateoc)) return call_params def close_out(self, params: appclientbarecallwithsendparams) -&gt; appcallparams: call_params: appcallparams = appcallparams(**self._get_bare_params(params.__dict__, oncomplete.closeoutoc)) return call_params def call(self, params: appclientbarecallwithcalloncompleteparams) -&gt; appcallparams: call_params: appcallparams = appcallparams(**self._get_bare_params(params.__dict__, oncomplete.noopoc)) return call_params class _appclientmethodcallparamsaccessor: def __init__(self, client: appclient) -&gt; none: self._client = client self._algorand = client._algorand self._app_id = client._app_id self._app_spec = client._app_spec self._bare_params_accessor = _appclientbareparamsaccessor(client) @property def bare(self) -&gt; _appclientbareparamsaccessor: return self._bare_params_accessor def fund_app_account(self, params: fundappaccountparams) -&gt; paymentparams: def random_note() -&gt; bytes: return base64.b64encode(os.urandom(16)) return paymentparams( sender=self._client._get_sender(params.sender), signer=self._client._get_signer(params.sender, params.signer), receiver=self._client.app_address, amount=params.amount, rekey_to=params.rekey_to, note=params.note random_note(), lease=params.lease, static_fee=params.static_fee, extra_fee=params.extra_fee, max_fee=params.max_fee, validity_window=params.validity_window, first_valid_round=params.first_valid_round, last_valid_round=params.last_valid_round, close_remainder_to=params.close_remainder_to, ) def opt_in(self, params: appclientmethodcallparams) -&gt; appcallmethodcallparams: input_params = self._get_abi_params(params.__dict__, on_complete=algosdk.transaction.oncomplete.optinoc) return appcallmethodcallparams(**input_params) def call(self, params: appclientmethodcallparams) -&gt; appcallmethodcallparams: input_params = self._get_abi_params(params.__dict__, on_complete=algosdk.transaction.oncomplete.noopoc) return appcallmethodcallparams(**input_params) def delete(self, params: appclientmethodcallparams) -&gt; appdeletemethodcallparams: input_params = self._get_abi_params( params.__dict__, on_complete=algosdk.transaction.oncomplete.deleteapplicationoc ) return appdeletemethodcallparams(**input_params) def update( self, params: appclientmethodcallparams | appclientmethodcallwithcompilationandsendparams ) -&gt; appupdatemethodcallparams: compile_params = ( self._client.compile( app_spec=self._client.app_spec, app_manager=self._algorand.app, deploy_time_params=params.deploy_time_params, updatable=params.updatable, deletable=params.deletable, ).__dict__ isinstance(params, appclientmethodcallwithcompilationandsendparams) else {} ) input_params = { **self._get_abi_params(params.__dict__, on_complete=algosdk.transaction.oncomplete.updateapplicationoc), **compile_params, } # filter input_params include fields valid appupdatemethodcallparams app_update_method_call_fields = {field.name field fields(appupdatemethodcallparams)} filtered_input_params = {k: v k, v input_params.items() k app_update_method_call_fields} return appupdatemethodcallparams(**filtered_input_params) def close_out(self, params: appclientmethodcallparams) -&gt; appcallmethodcallparams: input_params = self._get_abi_params(params.__dict__, on_complete=algosdk.transaction.oncomplete.closeoutoc) return appcallmethodcallparams(**input_params) def _get_abi_params(self, params: dict[str, any], on_complete: algosdk.transaction.oncomplete) -&gt; dict[str, any]: input_params = copy.deepcopy(params) input_params["app_id"] = self._app_id input_params["on_complete"] = on_complete input_params["sender"] = self._client._get_sender(params["sender"]) input_params["signer"] = self._client._get_signer(params["sender"], params["signer"]) params.get("method"): input_params["method"] = self._app_spec.get_arc56_method(params["method"]).to_abi_method() params.get("args"): input_params["args"] = self._client._get_abi_args_with_default_values( method_name_or_signature=params["method"], args=params["args"], sender=self._client._get_sender(input_params["sender"]), ) return input_params class _appclientbarecreatetransactionmethods: def __init__(self, client: appclient) -&gt; none: self._client = client self._algorand = client._algorand def update(self, params: appclientbarecallwithcompilationandsendparams) -&gt; transaction: return self._algorand.create_transaction.app_update(self._client.params.bare.update(params)) def opt_in(self, params: appclientbarecallwithsendparams) -&gt; transaction: return self._algorand.create_transaction.app_call(self._client.params.bare.opt_in(params)) def delete(self, params: appclientbarecallwithsendparams) -&gt; transaction: return self._algorand.create_transaction.app_call(self._client.params.bare.delete(params)) def clear_state(self, params: appclientbarecallwithsendparams) -&gt; transaction: return self._algorand.create_transaction.app_call(self._client.params.bare.clear_state(params)) def close_out(self, params: appclientbarecallwithsendparams) -&gt; transaction: return self._algorand.create_transaction.app_call(self._client.params.bare.close_out(params)) def call(self, params: appclientbarecallwithcalloncompleteparams) -&gt; transaction: return self._algorand.create_transaction.app_call(self._client.params.bare.call(params)) class _appclientmethodcalltransactioncreator: def __init__(self, client: appclient) -&gt; none: self._client = client self._algorand = client._algorand self._app_id = client._app_id self._app_spec = client._app_spec self._bare_create_transaction_methods = _appclientbarecreatetransactionmethods(client) @property def bare(self) -&gt; _appclientbarecreatetransactionmethods: return self._bare_create_transaction_methods def fund_app_account(self, params: fundappaccountparams) -&gt; transaction: return self._algorand.create_transaction.payment(self._client.params.fund_app_account(params)) def opt_in(self, params: appclientmethodcallparams) -&gt; builttransactions: return self._algorand.create_transaction.app_call_method_call(self._client.params.opt_in(params)) def update(self, params: appclientmethodcallparams) -&gt; builttransactions: return self._algorand.create_transaction.app_update_method_call(self._client.params.update(params)) def delete(self, params: appclientmethodcallparams) -&gt; builttransactions: return self._algorand.create_transaction.app_delete_method_call(self._client.params.delete(params)) def close_out(self, params: appclientmethodcallparams) -&gt; builttransactions: return self._algorand.create_transaction.app_call_method_call(self._client.params.close_out(params)) def call(self, params: appclientmethodcallparams) -&gt; builttransactions: return self._algorand.create_transaction.app_call_method_call(self._client.params.call(params)) class _appclientbaresendaccessor: def __init__(self, client: appclient) -&gt; none: self._client = client self._algorand = client._algorand self._app_id = client._app_id self._app_spec = client._app_spec def update( self, params: appclientbarecallwithcompilationandsendparams, ) -&gt; sendapptransactionresult: """send application update transaction. args: params: parameters update call compilation: optional compilation parameters max_rounds_to_wait: maximum number rounds wait confirmation suppress_log: whether suppress log output populate_app_call_resources: whether populate app call resources returns: result sending transaction """ compiled = self._client.compile_sourcemaps(params.deploy_time_params, params.updatable, params.deletable) bare_params = self._client.params.bare.update(params) bare_params.__setattr__("approval_program", bare_params.approval_program compiled.compiled_approval) bare_params.__setattr__("clear_state_program", bare_params.clear_state_program compiled.compiled_clear) call_result = self._client._handle_call_errors(lambda: self._algorand.send.app_update(bare_params)) return sendapptransactionresult(**{**call_result.__dict__, **(compiled.__dict__ compiled else {})}) def opt_in(self, params: appclientbarecallwithsendparams) -&gt; sendapptransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_call(self._client.params.bare.opt_in(params)) ) def delete(self, params: appclientbarecallwithsendparams) -&gt; sendapptransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_call(self._client.params.bare.delete(params)) ) def clear_state(self, params: appclientbarecallwithsendparams) -&gt; sendapptransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_call(self._client.params.bare.clear_state(params)) ) def close_out(self, params: appclientbarecallwithsendparams) -&gt; sendapptransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_call(self._client.params.bare.close_out(params)) ) def call(self, params: appclientbarecallwithcalloncompleteparams) -&gt; sendapptransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_call(self._client.params.bare.call(params)) ) class _appclientsendaccessor: def __init__(self, client: appclient) -&gt; none: self._client = client self._algorand = client._algorand self._app_id = client._app_id self._app_spec = client._app_spec self._bare_send_accessor = _appclientbaresendaccessor(client) @property def bare(self) -&gt; _appclientbaresendaccessor: return self._bare_send_accessor def fund_app_account(self, params: fundappaccountparams) -&gt; sendsingletransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.payment(self._client.params.fund_app_account(params)) ) def opt_in(self, params: appclientmethodcallwithsendparams) -&gt; sendapptransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_call_method_call(self._client.params.opt_in(params)) ) def delete(self, params: appclientmethodcallwithsendparams) -&gt; sendapptransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_delete_method_call(self._client.params.delete(params)) ) def update(self, params: appclientmethodcallwithcompilationandsendparams) -&gt; sendappupdatetransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_update_method_call(self._client.params.update(params)) ) def close_out(self, params: appclientmethodcallwithsendparams) -&gt; sendapptransactionresult: return self._client._handle_call_errors( # type: ignore[no-any-return] lambda: self._algorand.send.app_call_method_call(self._client.params.close_out(params)) ) def call(self, params: appclientmethodcallwithsendparams) -&gt; sendapptransactionresult: is_read_only_call = ( params.on_complete == algosdk.transaction.oncomplete.noopoc params.on_complete none ) self._app_spec.get_arc56_method(params.method).readonly is_read_only_call: method_call_to_simulate = self._algorand.new_group().add_app_call_method_call( self._client.params.call(params) ) simulate_response = self._client._handle_call_errors( lambda: method_call_to_simulate.simulate( allow_unnamed_resources=params.populate_app_call_resources true, skip_signatures=true, allow_more_logs=true, allow_empty_signatures=true, extra_opcode_budget=none, exec_trace_config=none, simulation_round=none, ) ) return sendapptransactionresult( tx_ids=simulate_response.tx_ids, transactions=simulate_response.transactions, transaction=simulate_response.transactions[-1], confirmation=simulate_response.confirmations[-1] simulate_response.confirmations else b"", confirmations=simulate_response.confirmations, group_id=simulate_response.group_id "", returns=simulate_response.returns, abi_return=simulate_response.returns[-1], ) return self._client._handle_call_errors( lambda: self._algorand.send.app_call_method_call(self._client.params.call(params)) ) @dataclass(kw_only=true, frozen=true) class appclientparams: """full parameters creating app client""" app_spec: arc56contract | arc32contract | str # using string quotes since types may defined elsewhere algorand: algorandclientprotocol # using string quotes since type may defined elsewhere app_id: int app_name: str | none = none default_sender: str | bytes | none = none # address string bytes default_signer: transactionsigner | none = none approval_source_map: sourcemap | none = none clear_source_map: sourcemap | none = none class appclient: def __init__(self, params: appclientparams) -&gt; none: self._app_id = params.app_id self._app_spec = self.normalise_app_spec(params.app_spec) self._algorand = params.algorand self._app_address = algosdk.logic.get_application_address(self._app_id) self._app_name = params.app_name self._app_spec.name self._default_sender = params.default_sender self._default_signer = params.default_signer self._approval_source_map = params.approval_source_map self._clear_source_map = params.clear_source_map self._state_accessor = _appclientstateaccessor(self) self._params_accessor = _appclientmethodcallparamsaccessor(self) self._send_accessor = _appclientsendaccessor(self) self._create_transaction_accessor = _appclientmethodcalltransactioncreator(self) @property def algorand(self) -&gt; algorandclientprotocol: return self._algorand @property def app_id(self) -&gt; int: return self._app_id @property def app_address(self) -&gt; str: return self._app_address @property def app_name(self) -&gt; str: return self._app_name @property def app_spec(self) -&gt; arc56contract: return self._app_spec @property def state(self) -&gt; _appclientstateaccessor: return self._state_accessor @property def params(self) -&gt; _appclientmethodcallparamsaccessor: return self._params_accessor @property def send(self) -&gt; _appclientsendaccessor: return self._send_accessor @property def create_transaction(self) -&gt; _appclientmethodcalltransactioncreator: return self._create_transaction_accessor @staticmethod def normalise_app_spec(app_spec: arc56contract | arc32contract | str) -&gt; arc56contract: isinstance(app_spec, str): spec_dict = json.loads(app_spec) spec = arc32contract.from_json(app_spec) "hints" spec_dict else spec_dict else: spec = app_spec match spec: case arc56contract(): return spec case arc32contract(): return arc56contract.from_arc32(spec.to_json()) case dict(): return arc56contract.from_dict(spec) case _: raise valueerror("invalid app spec format") @staticmethod def from_network( app_spec: arc56contract | arc32contract | str, algorand: algorandclientprotocol, app_name: str | none = none, default_sender: str | bytes | none = none, default_signer: transactionsigner | none = none, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, ) -&gt; appclient: network = algorand.client.network() app_spec = appclient.normalise_app_spec(app_spec) network_names = [network.genesis_hash] network.is_localnet: network_names.append("localnet") network.is_mainnet: network_names.append("mainnet") network.is_testnet: network_names.append("testnet") available_app_spec_networks = list(app_spec.networks.keys()) app_spec.networks else [] network_index = next((i i, n enumerate(available_app_spec_networks) n network_names), none) network_index none: raise exception(f"no app id found network {json.dumps(network_names)} app spec") app_id = app_spec.networks[available_app_spec_networks[network_index]].app_id # type: ignore[index] return appclient( appclientparams( app_id=app_id, app_spec=app_spec, algorand=algorand, app_name=app_name, default_sender=default_sender, default_signer=default_signer, approval_source_map=approval_source_map, clear_source_map=clear_source_map, ) ) @staticmethod def from_creator_and_name( creator_address: str, app_name: str, app_spec: arc56contract | arc32contract | str, algorand: algorandclientprotocol, default_sender: str | bytes | none = none, default_signer: transactionsigner | none = none, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, ignore_cache: bool | none = none, app_lookup_cache: applookup | none = none, ) -&gt; appclient: app_spec_ = appclient.normalise_app_spec(app_spec) app_lookup = app_lookup_cache algorand.app_deployer.get_creator_apps_by_name( creator_address=creator_address, ignore_cache=ignore_cache false ) app_metadata = app_lookup.apps.get(app_name app_spec_.name) app_metadata: raise valueerror(f"app found creator {creator_address} name {app_name app_spec_.name}") return appclient( appclientparams( app_id=app_metadata.app_id, app_spec=app_spec_, algorand=algorand, app_name=app_name, default_sender=default_sender, default_signer=default_signer, approval_source_map=approval_source_map, clear_source_map=clear_source_map, ) ) @staticmethod def compile( app_spec: arc56contract, app_manager: appmanager, deploy_time_params: tealtemplateparams | none = none, updatable: bool | none = none, deletable: bool | none = none, ) -&gt; appclientcompilationresult: def is_base64(s: str) -&gt; bool: try: return base64.b64encode(base64.b64decode(s)).decode() == except exception: return false app_spec.source: app_spec.byte_code app_spec.byte_code.approval app_spec.byte_code.clear: raise valueerror(f"attempt compile app {app_spec.name} without source byte_code") return appclientcompilationresult( approval_program=base64.b64decode(app_spec.byte_code.approval), clear_state_program=base64.b64decode(app_spec.byte_code.clear), ) compiled_approval = app_manager.compile_teal_template( app_spec.source.get_decoded_approval(), template_params=deploy_time_params, deployment_metadata=( {"updatable": updatable false, "deletable": deletable false} updatable none deletable none else none ), ) compiled_clear = app_manager.compile_teal_template( app_spec.source.get_decoded_clear(), template_params=deploy_time_params, ) config.debug config.project_root: persist_sourcemaps( sources=[ persistsourcemapinput( compiled_teal=compiled_approval, app_name=app_spec.name, file_name="approval.teal" ), persistsourcemapinput(compiled_teal=compiled_clear, app_name=app_spec.name, file_name="clear.teal"), ], project_root=config.project_root, client=app_manager._algod, with_sources=true, ) return appclientcompilationresult( approval_program=compiled_approval.compiled_base64_to_bytes, compiled_approval=compiled_approval, clear_state_program=compiled_clear.compiled_base64_to_bytes, compiled_clear=compiled_clear, ) @staticmethod def _expose_logic_error_static( # noqa: c901 *, e: exception, app_spec: arc56contract, is_clear_state_program: bool = false, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, program: bytes | none = none, approval_source_info: programsourceinfo | none = none, clear_source_info: programsourceinfo | none = none, ) -&gt; exception: """takes error may include logic error re-exposes source info.""" source_map = clear_source_map is_clear_state_program else approval_source_map error_details = parse_logic_error(str(e)) error_details: return e # pc value find arc56 sourceinfo arc56_pc = error_details["pc"] program_source_info = clear_source_info is_clear_state_program else approval_source_info # offset apply pc using cblocks pc offset method cblocks_offset = 0 # program uses cblocks offset, need adjust pc accordingly program_source_info program_source_info.pc_offset_method == pcoffsetmethod.cblocks: program: raise exception("program bytes required calculate arc56 cblocks pc offset") cblocks_offset = get_constant_block_offset(program) arc56_pc = error_details["pc"] - cblocks_offset # find source info pc get error message source_info = none program_source_info program_source_info.source_info: source_info = next( (s program_source_info.source_info isinstance(s, sourceinfo) arc56_pc s.pc), none, ) error_message = source_info.error_message source_info else none # source display teal error message hasattr(app_spec, "source"): program_source = ( ( app_spec.source.get_decoded_clear() is_clear_state_program else app_spec.source.get_decoded_approval() ) app_spec.source else none ) custom_get_line_for_pc = none def get_line_for_pc(input_pc: int) -&gt; int | none: program_source_info: return none teal = [line.teal line program_source_info.source_info input_pc - cblocks_offset line.pc] return teal[0] teal else none source_map: custom_get_line_for_pc = get_line_for_pc program_source: e = logicerror( logic_error_str=str(e), program=program_source, source_map=source_map, transaction_id=error_details["transaction_id"], message=error_details["message"], pc=error_details["pc"], logic_error=e, get_line_for_pc=custom_get_line_for_pc, traces=none, ) error_message: import app_id = re.search(r"(?&lt;=app=)\d+", str(e)) tx_id = re.search(r"(?&lt;=transaction )\s+(?=:)", str(e)) error = exception( f"runtime error executing {app_spec.name} " f"(appid: {app_id.group() app_id else ''}) transaction " f"{tx_id.group() tx_id else ''}: {error_message}" ) error.__cause__ = e return error return e # note: method overloads hence slightly different name, ts instance/static methods named 'compile' def compile_sourcemaps( self, deploy_time_params: tealtemplateparams | none = none, updatable: bool | none = none, deletable: bool | none = none, ) -&gt; appclientcompilationresult: result = appclient.compile(self._app_spec, self._algorand.app, deploy_time_params, updatable, deletable) result.compiled_approval: self._approval_source_map = result.compiled_approval.source_map result.compiled_clear: self._clear_source_map = result.compiled_clear.source_map return result def clone( self, app_name: str | none = none, default_sender: str | bytes | none = none, default_signer: transactionsigner | none = none, approval_source_map: sourcemap | none = none, clear_source_map: sourcemap | none = none, ) -&gt; appclient: return appclient( appclientparams( app_id=self._app_id, algorand=self._algorand, app_spec=self._app_spec, app_name=app_name self._app_name, default_sender=default_sender self._default_sender, default_signer=default_signer self._default_signer, approval_source_map=approval_source_map self._approval_source_map, clear_source_map=clear_source_map self._clear_source_map, ) ) def export_source_maps(self) -&gt; appsourcemaps: self._approval_source_map self._clear_source_map: raise valueerror( "unable export source maps; loaded client - " "you need call create, update, deploy first" ) return appsourcemaps( approval_source_map=self._approval_source_map, clear_source_map=self._clear_source_map, ) def import_source_maps(self, source_maps: appsourcemaps) -&gt; none: source_maps.approval_source_map: raise valueerror("approval source map required") source_maps.clear_source_map: raise valueerror("clear source map required") isinstance(source_maps.approval_source_map, dict | sourcemap): raise valueerror( "approval source map supplied invalid type. must raw dict `algosdk.source_map.sourcemap`" ) isinstance(source_maps.clear_source_map, dict | sourcemap): raise valueerror( "clear source map supplied invalid type. must raw dict `algosdk.source_map.sourcemap`" ) self._approval_source_map = ( sourcemap(source_map=source_maps.approval_source_map) isinstance(source_maps.approval_source_map, dict) else source_maps.approval_source_map ) self._clear_source_map = ( sourcemap(source_map=source_maps.clear_source_map) isinstance(source_maps.clear_source_map, dict) else source_maps.clear_source_map ) def get_local_state(self, address: str) -&gt; dict[str, appstate]: return self._state_accessor.get_local_state(address) def get_global_state(self) -&gt; dict[str, appstate]: return self._state_accessor.get_global_state() def get_box_names(self) -&gt; list[boxname]: return self._algorand.app.get_box_names(self._app_id) def get_box_value(self, name: boxidentifier) -&gt; bytes: return self._algorand.app.get_box_value(self._app_id, name) def get_box_value_from_abi_type(self, name: boxidentifier, abi_type: abitype) -&gt; abivalue: return self._algorand.app.get_box_value_from_abi_type(self._app_id, name, abi_type) def get_box_values(self, filter_func: callable[[boxname], bool] | none = none) -&gt; list[boxvalue]: names = [n n self.get_box_names() filter_func filter_func(n)] values = self._algorand.app.get_box_values(self.app_id, [n.name_raw n names]) return [boxvalue(name=n, value=v) n, v zip(names, values, strict=false)] def get_box_values_from_abi_type( self, abi_type: abitype, filter_func: callable[[boxname], bool] | none = none ) -&gt; list[boxabivalue]: # get box names apply filter provided names = self.get_box_names() filter_func: names = [name name names filter_func(name)] # get values filtered names decode values = self._algorand.app.get_box_values_from_abi_type( self.app_id, [name.name_raw name names], abi_type ) # return list boxabivalue objects return [boxabivalue(name=name, value=values[i]) i, name enumerate(names)] def fund_app_account(self, params: fundappaccountparams) -&gt; sendsingletransactionresult: return self.send.fund_app_account(params) def _expose_logic_error(self, e: exception, is_clear_state_program: bool = false) -&gt; exception: # noqa: fbt001, fbt002 """takes error may include logic error call current app re-exposes error include source code information via source map arc-56 spec. args: e: error parse is_clear_state_program: whether code running clear state program (defaults approval program) returns: new error, logic error source map wrapped error source details """ # get source info based program type source_info = none hasattr(self._app_spec, "source_info") self._app_spec.source_info: source_info = ( self._app_spec.source_info.clear is_clear_state_program else self._app_spec.source_info.approval ) pc_offset_method = source_info.pc_offset_method source_info else none program: bytes | none = none pc_offset_method == "cblocks": # todo: cache deploy app updateable app_info = self._algorand.app.get_by_id(self.app_id) program = app_info.clear_state_program is_clear_state_program else app_info.approval_program return appclient._expose_logic_error_static( e=e, app_spec=self._app_spec, is_clear_state_program=is_clear_state_program, approval_source_map=self._approval_source_map, clear_source_map=self._clear_source_map, program=program, approval_source_info=(self._app_spec.source_info.approval self._app_spec.source_info else none), clear_source_info=(self._app_spec.source_info.clear self._app_spec.source_info else none), ) def _handle_call_errors(self, call: callable[[], t]) -&gt; t: """make given call catch errors, augmenting debugging information re-throwing.""" try: return call() except exception e: raise self._expose_logic_error(e=e) none def _get_sender(self, sender: str | none) -&gt; str: sender self._default_sender: raise exception( f"no sender provided default sender present app client call app {self.app_name}" ) return sender self._default_sender # type: ignore[return-value] def _get_signer(self, sender: str | none, signer: transactionsigner | none) -&gt; transactionsigner | none: return signer self._default_signer sender sender == self._default_sender else none def _get_bare_params(self, params: dict[str, any], on_complete: algosdk.transaction.oncomplete) -&gt; dict[str, any]: """get bare parameters application calls. args: params: parameters process on_complete: oncomplete value transaction returns: processed parameters defaults filled """ sender = self._get_sender(params.get("sender")) return { **params, "app_id": self._app_id, "sender": sender, "signer": self._get_signer(params.get("sender"), params.get("signer")), "on_complete": on_complete, } def _get_abi_args_with_default_values( # noqa: c901, plr0912 self, *, method_name_or_signature: str, args: list[abivalue | abistruct | appmethodcalltransactionargument | none] | none, sender: str, ) -&gt; list[any]: """get abi args default values filled in. args: method_name_or_signature: method name abi signature args: optional list argument values sender: sender address returns: list argument values defaults filled raises: valueerror: required argument missing default value lookup fails """ method = self._app_spec.get_arc56_method(method_name_or_signature) result = [] i, method_arg enumerate(method.args): # get provided arg value arg_value = args[i] args &lt; len(args) else none arg_value none: # convert struct tuple needed method_arg.struct isinstance(arg_value, dict): arg_value = get_abi_tuple_from_abi_struct( arg_value, self._app_spec.structs[method_arg.struct], self._app_spec.structs ) result.append(arg_value) continue # handle default value arg provided default_value = method_arg.default_value default_value: match default_value.source: case "literal": value_raw = base64.b64decode(default_value.data) value_type = default_value.type method_arg.type result.append(get_abi_decoded_value(value_raw, value_type, self._app_spec.structs)) case "method": # get method return value default_method = self._app_spec.get_arc56_method(default_value.data) empty_args = [none] * len(default_method.args) call_result = self._algorand.send.app_call_method_call( appcallmethodcallparams( app_id=self._app_id, method=algosdk.abi.method.from_signature(default_value.data), args=empty_args, sender=sender, ) ) call_result.abi_return: raise valueerror("default value method call return value") isinstance(call_result.abi_return, dict): # convert struct return value tuple result.append( get_abi_tuple_from_abi_struct( call_result.abi_return, self._app_spec.structs[str(default_method.returns.type)], self._app_spec.structs, ) ) elif call_result.abi_return.value: result.append(call_result.abi_return.value) case "local" | "global": # get state value state = ( self.get_global_state() default_value.source == "global" else self.get_local_state(sender) ) value = next((s state.values() s.key_base64 == default_value.data), none) value: raise valueerror( f"key '{default_value.data}' found {default_value.source} " f"storage argument {method_arg.name f'arg{i+1}'}" ) value.value_raw: value_type = default_value.type method_arg.type result.append(get_abi_decoded_value(value.value_raw, value_type, self._app_spec.structs)) else: result.append(value.value) case "box": # get box value box_name = base64.b64decode(default_value.data) box_value = self._algorand.app.get_box_value(self._app_id, box_name) value_type = default_value.type method_arg.type result.append(get_abi_decoded_value(box_value, value_type, self._app_spec.structs)) elif algosdk.abi.is_abi_transaction_type(method_arg.type): # error required non-txn arg missing raise valueerror( f"no value provided required argument " f"{method_arg.name f'arg{i+1}'} call method {method.name}" ) return result def _get_abi_params(self, params: dict[str, any], on_complete: algosdk.transaction.oncomplete) -&gt; dict[str, any]: sender = self._get_sender(params.get("sender")) method = self._app_spec.get_arc56_method(params["method"]) args = self._get_abi_args_with_default_values( method_name_or_signature=params["method"], args=params.get("args"), sender=sender ) return { **params, "appid": self._app_id, "sender": sender, "signer": self._get_signer(params.get("sender"), params.get("signer")), "method": method, "oncomplete": on_complete, "args": args, }</file><file name="applications/app_manager.py">import base64 collections.abc import mapping typing import any, cast import algosdk import algosdk.atomic_transaction_composer import algosdk.box_reference algosdk.atomic_transaction_composer import accounttransactionsigner algosdk.box_reference import boxreference algosdkboxreference algosdk.logic import get_application_address algosdk.source_map import sourcemap algosdk.v2client import algod algokit_utils.applications.abi import abireturn, abitype, abivalue algokit_utils.models.application import ( appinformation, appstate, compiledteal, ) algokit_utils.models.state import boxidentifier, boxname, boxreference, datatypeflag, tealtemplateparams __all__ = [ "deletable_template_name", "updatable_template_name", "appmanager", ] updatable_template_name = "tmpl_updatable" """the name teal template variable deploy-time immutability control.""" deletable_template_name = "tmpl_deletable" """the name teal template variable deploy-time permanence control.""" def _is_valid_token_character(char: str) -&gt; bool: return char.isalnum() char == "_" def _last_token_base64(line: str, idx: int) -&gt; bool: try: *_, last = line[:idx].split() except valueerror: return false return last ("base64", "b64") def _find_template_token(line: str, token: str, start: int = 0, end: int = -1) -&gt; int | none: """find first template token within line teal. matches outside quotes returned. full token matches returned, i.e. tmpl_str match tmpl_string returns none found""" end &lt; 0: end = len(line) idx = start idx &lt; end: token_idx = _find_unquoted_string(line, token, idx, end) token_idx none: break trailing_idx = token_idx + len(token) (token_idx == 0 _is_valid_token_character(line[token_idx - 1])) ( # word boundary start trailing_idx &gt;= len(line) _is_valid_token_character(line[trailing_idx]) # word boundary end ): return token_idx idx = trailing_idx return none def _find_unquoted_string(line: str, token: str, start: int = 0, end: int = -1) -&gt; int | none: """find first string within line teal. matches outside quotes base64 returned. returns none found""" end &lt; 0: end = len(line) idx = start in_quotes = in_base64 = false idx &lt; end: current_char = line[idx] match current_char: # enter base64 case " " | "(" in_quotes _last_token_base64(line, idx): in_base64 = true # exit base64 case " " | ")" in_quotes in_base64: in_base64 = false # escaped char case "\\" in_quotes: # skip next character idx += 1 # quote boundary case '"': in_quotes = in_quotes # test match case _ in_quotes in_base64 line.startswith(token, idx): # match quotes string matches return idx idx += 1 return none def _replace_template_variable(program_lines: list[str], template_variable: str, value: str) -&gt; tuple[list[str], int]: result: list[str] = [] match_count = 0 token = f"tmpl_{template_variable}" template_variable.startswith("tmpl_") else template_variable token_idx_offset = len(value) - len(token) line program_lines: comment_idx = _find_unquoted_string(line, "//") comment_idx none: comment_idx = len(line) code = line[:comment_idx] comment = line[comment_idx:] trailing_idx = 0 true: token_idx = _find_template_token(code, token, trailing_idx) token_idx none: break trailing_idx = token_idx + len(token) prefix = code[:token_idx] suffix = code[trailing_idx:] code = f"{prefix}{value}{suffix}" match_count += 1 trailing_idx += token_idx_offset result.append(code + comment) return result, match_count class appmanager: def __init__(self, algod_client: algod.algodclient): self._algod = algod_client self._compilation_results: dict[str, compiledteal] = {} def compile_teal(self, teal_code: str) -&gt; compiledteal: teal_code self._compilation_results: return self._compilation_results[teal_code] compiled = self._algod.compile(teal_code, source_map=true) result = compiledteal( teal=teal_code, compiled=compiled["result"], compiled_hash=compiled["hash"], compiled_base64_to_bytes=base64.b64decode(compiled["result"]), source_map=sourcemap(compiled.get("sourcemap", {})), ) self._compilation_results[teal_code] = result return result def compile_teal_template( self, teal_template_code: str, template_params: tealtemplateparams | none = none, deployment_metadata: mapping[str, bool] | none = none, ) -&gt; compiledteal: teal_code = appmanager.strip_teal_comments(teal_template_code) teal_code = appmanager.replace_template_variables(teal_code, template_params {}) deployment_metadata: teal_code = appmanager.replace_teal_template_deploy_time_control_params(teal_code, deployment_metadata) return self.compile_teal(teal_code) def get_compilation_result(self, teal_code: str) -&gt; compiledteal | none: return self._compilation_results.get(teal_code) def get_by_id(self, app_id: int) -&gt; appinformation: app = self._algod.application_info(app_id) assert isinstance(app, dict) app_params = app["params"] return appinformation( app_id=app_id, app_address=get_application_address(app_id), approval_program=base64.b64decode(app_params["approval-program"]), clear_state_program=base64.b64decode(app_params["clear-state-program"]), creator=app_params["creator"], local_ints=app_params["local-state-schema"]["num-uint"], local_byte_slices=app_params["local-state-schema"]["num-byte-slice"], global_ints=app_params["global-state-schema"]["num-uint"], global_byte_slices=app_params["global-state-schema"]["num-byte-slice"], extra_program_pages=app_params.get("extra-program-pages", 0), global_state=self.decode_app_state(app_params.get("global-state", [])), ) def get_global_state(self, app_id: int) -&gt; dict[str, appstate]: return self.get_by_id(app_id).global_state def get_local_state(self, app_id: int, address: str) -&gt; dict[str, appstate]: app_info = self._algod.account_application_info(address, app_id) assert isinstance(app_info, dict) app_info.get("app-local-state", {}).get("key-value"): raise valueerror("couldn't find local state") return self.decode_app_state(app_info["app-local-state"]["key-value"]) def get_box_names(self, app_id: int) -&gt; list[boxname]: box_result = self._algod.application_boxes(app_id) assert isinstance(box_result, dict) return [ boxname( name_raw=base64.b64decode(b["name"]), name_base64=b["name"], name=base64.b64decode(b["name"]).decode("utf-8"), ) b box_result["boxes"] ] def get_box_value(self, app_id: int, box_name: boxidentifier) -&gt; bytes: name = appmanager.get_box_reference(box_name)[1] box_result = self._algod.application_box_by_name(app_id, name) assert isinstance(box_result, dict) return bytes(box_result["value"], "utf-8") def get_box_values(self, app_id: int, box_names: list[boxidentifier]) -&gt; list[bytes]: return [self.get_box_value(app_id, box_name) box_name box_names] def get_box_value_from_abi_type(self, app_id: int, box_name: boxidentifier, abi_type: abitype) -&gt; abivalue: value = self.get_box_value(app_id, box_name) try: parse_to_tuple = isinstance(abi_type, algosdk.abi.tupletype) decoded_value = abi_type.decode(base64.b64decode(value)) return tuple(decoded_value) parse_to_tuple else decoded_value except exception e: raise valueerror(f"failed decode box value {value.decode('utf-8')} abi type {abi_type}") e def get_box_values_from_abi_type( self, app_id: int, box_names: list[boxidentifier], abi_type: abitype ) -&gt; list[abivalue]: return [self.get_box_value_from_abi_type(app_id, box_name, abi_type) box_name box_names] @staticmethod def get_box_reference(box_id: boxidentifier | boxreference) -&gt; tuple[int, bytes]: isinstance(box_id, (boxreference | algosdkboxreference)): return box_id.app_index, box_id.name name = b"" isinstance(box_id, str): name = box_id.encode("utf-8") elif isinstance(box_id, bytes): name = box_id elif isinstance(box_id, accounttransactionsigner): name = cast( bytes, algosdk.encoding.decode_address(algosdk.account.address_from_private_key(box_id.private_key)) ) else: raise valueerror(f"invalid box identifier type: {type(box_id)}") return 0, name @staticmethod def get_abi_return( confirmation: algosdk.v2client.algod.algodresponsetype, method: algosdk.abi.method | none = none ) -&gt; abireturn | none: """get abi return value transaction confirmation.""" method: return none # use sdk's built-in abi result parsing atc = algosdk.atomic_transaction_composer.atomictransactioncomposer() abi_result = atc.parse_result( method, # map transaction index abi method "dummy_txn", # list transaction info confirmation, # type: ignore[arg-type] ) abi_result: return none return abireturn(abi_result) @staticmethod def decode_app_state(state: list[dict[str, any]]) -&gt; dict[str, appstate]: state_values: dict[str, appstate] = {} state_val state: key_base64 = state_val["key"] key_raw = base64.b64decode(key_base64) key = key_raw.decode("utf-8") teal_value = state_val["value"] data_type_flag = teal_value.get("action", teal_value.get("type")) data_type_flag == datatypeflag.bytes: value_base64 = teal_value.get("bytes", "") value_raw = base64.b64decode(value_base64) state_values[key] = appstate( key_raw=key_raw, key_base64=key_base64, value_raw=value_raw, value_base64=value_base64, value=value_raw.decode("utf-8"), ) elif data_type_flag == datatypeflag.uint: value = teal_value.get("uint", 0) state_values[key] = appstate( key_raw=key_raw, key_base64=key_base64, value_raw=none, value_base64=none, value=int(value), ) else: raise valueerror(f"received unknown state data type {data_type_flag}") return state_values @staticmethod def replace_template_variables(program: str, template_values: tealtemplateparams) -&gt; str: program_lines = program.splitlines() template_variable_name, template_value template_values.items(): match template_value: case int(): value = str(template_value) case str(): value = "0x" + template_value.encode("utf-8").hex() case bytes(): value = "0x" + template_value.hex() case _: raise valueerror( f"unexpected template value type {template_variable_name}: {template_value.__class__}" ) program_lines, _ = _replace_template_variable(program_lines, template_variable_name, value) return "\n".join(program_lines) @staticmethod def replace_teal_template_deploy_time_control_params(teal_template_code: str, params: mapping[str, bool]) -&gt; str: params.get("updatable") none: updatable_template_name teal_template_code: raise valueerror( f"deploy-time updatability control requested app deployment, {updatable_template_name} " "not present teal code" ) teal_template_code = teal_template_code.replace(updatable_template_name, str(int(params["updatable"]))) params.get("deletable") none: deletable_template_name teal_template_code: raise valueerror( f"deploy-time deletability control requested app deployment, {deletable_template_name} " "not present teal code" ) teal_template_code = teal_template_code.replace(deletable_template_name, str(int(params["deletable"]))) return teal_template_code @staticmethod def strip_teal_comments(teal_code: str) -&gt; str: def _strip_comment(line: str) -&gt; str: comment_idx = _find_unquoted_string(line, "//") comment_idx none: return line return line[:comment_idx].rstrip() return "\n".join(_strip_comment(line) line teal_code.splitlines())</file><file name="applications/app_deployer.py">import base64 import dataclasses import json dataclasses import asdict, dataclass enum import enum typing import literal algosdk.logic import get_application_address algosdk.v2client.indexer import indexerclient algokit_utils.applications.app_manager import appmanager algokit_utils.config import config algokit_utils.models.state import tealtemplateparams algokit_utils.transactions.transaction_composer import ( appcreatemethodcallparams, appcreateparams, appdeletemethodcallparams, appdeleteparams, appupdatemethodcallparams, appupdateparams, ) algokit_utils.transactions.transaction_sender import ( algorandclienttransactionsender, sendappcreatetransactionresult, sendapptransactionresult, sendappupdatetransactionresult, ) __all__ = [ "app_deploy_note_dapp", "appdeploymetadata", "appdeployparams", "appdeployresponse", "appdeployer", "applookup", "appmetadata", "appreference", "onschemabreak", "onupdate", "operationperformed", ] app_deploy_note_dapp: str = "algokit_deployer" logger = config.logger @dataclasses.dataclass class appreference: """information algorand app""" app_id: int app_address: str @dataclasses.dataclass class appdeploymetadata: """metadata application stored transaction note creation. note serialized json prefixed {py:data}`note_prefix` stored transaction note field part {py:meth}`applicationclient.deploy` """ name: str version: str deletable: bool | none updatable: bool | none @dataclasses.dataclass class appmetadata(appreference, appdeploymetadata): """metadata deployed app""" created_round: int updated_round: int created_metadata: appdeploymetadata deleted: bool @dataclasses.dataclass class applookup: """cache {py:class}`appmetadata` specific `creator` used argument {py:class}`applicationclient` reduce number calls deploying multiple apps discovering multiple app_ids """ creator: str apps: dict[str, appmetadata] = dataclasses.field(default_factory=dict) class onschemabreak(str, enum): """action take application's schema breaking changes""" fail = "fail" """fail deployment""" replaceapp = "replace_app" """create new application delete old application single transaction""" appendapp = "append_app" """create new application""" class onupdate(str, enum): """action take application updated""" fail = "fail" """fail deployment""" updateapp = "update_app" """update application new approval clear programs""" replaceapp = "replace_app" """create new application delete old application single transaction""" appendapp = "append_app" """create new application""" class operationperformed(str, enum): """describes actions taken deployment""" nothing = "nothing" """an existing application found""" create = "create" """no existing application found, created new application""" update = "update" """an existing application found, date, updated latest version""" replace = "replace" """an existing application found, date, created new application deleted original""" @dataclass(kw_only=true) class appdeployparams: """parameters deploying app""" metadata: appdeploymetadata deploy_time_params: tealtemplateparams | none = none on_schema_break: literal["replace", "fail", "append"] | onschemabreak = onschemabreak.fail on_update: literal["update", "replace", "fail", "append"] | onupdate = onupdate.fail create_params: appcreateparams | appcreatemethodcallparams update_params: appupdateparams | appupdatemethodcallparams delete_params: appdeleteparams | appdeletemethodcallparams existing_deployments: applookup | none = none ignore_cache: bool = false max_fee: int | none = none max_rounds_to_wait: int | none = none suppress_log: bool = false populate_app_call_resources: bool = false # union type possible deploy results @dataclass(frozen=true) class appdeployresponse: app: appmetadata operation_performed: operationperformed create_response: sendappcreatetransactionresult | none = none update_response: sendappupdatetransactionresult | none = none delete_response: sendapptransactionresult | none = none class appdeployer: """manages deployment deployment metadata applications""" def __init__( self, app_manager: appmanager, transaction_sender: algorandclienttransactionsender, indexer: indexerclient | none = none, ): self._app_manager = app_manager self._transaction_sender = transaction_sender self._indexer = indexer self._app_lookups: dict[str, applookup] = {} def _create_deploy_note(self, metadata: appdeploymetadata) -&gt; bytes: note = { "dapp_name": app_deploy_note_dapp, "format": "j", "data": metadata.__dict__, } return json.dumps(note).encode() def deploy(self, deployment: appdeployparams) -&gt; appdeployresponse: # create new instances updated notes logger.info( f"idempotently deploying app \"{deployment.metadata.name}\" creator " f"{deployment.create_params.sender} using {len(deployment.create_params.approval_program)} bytes " f"{'teal code' isinstance(deployment.create_params.approval_program, str) else 'avm bytecode'} " f"{len(deployment.create_params.clear_state_program)} bytes " f"{'teal code' isinstance(deployment.create_params.clear_state_program, str) else 'avm bytecode'}", suppress_log=deployment.suppress_log, ) note = self._create_deploy_note(deployment.metadata) create_params = dataclasses.replace(deployment.create_params, note=note) update_params = dataclasses.replace(deployment.update_params, note=note) deployment = dataclasses.replace( deployment, create_params=create_params, update_params=update_params, ) # validate inputs ( deployment.existing_deployments deployment.existing_deployments.creator != deployment.create_params.sender ): raise valueerror( f"received invalid existingdeployments value creator " f"{deployment.existing_deployments.creator} attempting deploy " f"for creator {deployment.create_params.sender}" ) deployment.existing_deployments self._indexer: raise valueerror( "didn't receive indexer client appmanager created, " "but also receive existingdeployments cache - one must provided" ) # compile code needed approval_program = deployment.create_params.approval_program clear_program = deployment.create_params.clear_state_program isinstance(approval_program, str): compiled_approval = self._app_manager.compile_teal_template( approval_program, deployment.deploy_time_params, deployment.metadata.__dict__, ) approval_program = compiled_approval.compiled_base64_to_bytes isinstance(clear_program, str): compiled_clear = self._app_manager.compile_teal_template( clear_program, deployment.deploy_time_params, ) clear_program = compiled_clear.compiled_base64_to_bytes # get existing app metadata apps = deployment.existing_deployments self.get_creator_apps_by_name( creator_address=deployment.create_params.sender, ignore_cache=deployment.ignore_cache, ) existing_app = apps.apps.get(deployment.metadata.name) existing_app existing_app.deleted: return self._create_app( deployment=deployment, approval_program=approval_program, clear_program=clear_program, ) # check changes existing_app_record = self._app_manager.get_by_id(existing_app.app_id) existing_approval = base64.b64encode(existing_app_record.approval_program).decode() existing_clear = base64.b64encode(existing_app_record.clear_state_program).decode() new_approval = base64.b64encode(approval_program).decode() new_clear = base64.b64encode(clear_program).decode() is_update = new_approval != existing_approval new_clear != existing_clear is_schema_break = ( existing_app_record.local_ints &lt; (deployment.create_params.schema.get("local_ints", 0) deployment.create_params.schema else 0) existing_app_record.global_ints &lt; (deployment.create_params.schema.get("global_ints", 0) deployment.create_params.schema else 0) existing_app_record.local_byte_slices &lt; (deployment.create_params.schema.get("local_byte_slices", 0) deployment.create_params.schema else 0) existing_app_record.global_byte_slices &lt; (deployment.create_params.schema.get("global_byte_slices", 0) deployment.create_params.schema else 0) ) is_schema_break: logger.warning( f"detected breaking app schema change app {existing_app.app_id}:", extra={ "from": { "global_ints": existing_app_record.global_ints, "global_byte_slices": existing_app_record.global_byte_slices, "local_ints": existing_app_record.local_ints, "local_byte_slices": existing_app_record.local_byte_slices, }, "to": deployment.create_params.schema, }, suppress_log=deployment.suppress_log, ) return self._handle_schema_break( deployment=deployment, existing_app=existing_app, approval_program=approval_program, clear_program=clear_program, ) is_update: return self._handle_update( deployment=deployment, existing_app=existing_app, approval_program=approval_program, clear_program=clear_program, ) logger.debug("no detected changes app, nothing do.", suppress_log=deployment.suppress_log) return appdeployresponse( app=existing_app, operation_performed=operationperformed.nothing, ) def _create_app( self, deployment: appdeployparams, approval_program: bytes, clear_program: bytes, ) -&gt; appdeployresponse: """create new application""" isinstance(deployment.create_params, appcreatemethodcallparams): create_response = self._transaction_sender.app_create_method_call( appcreatemethodcallparams( **{ **asdict(deployment.create_params), "approval_program": approval_program, "clear_state_program": clear_program, } ) ) else: create_response = self._transaction_sender.app_create( appcreateparams( **{ **asdict(deployment.create_params), "approval_program": approval_program, "clear_state_program": clear_program, } ) ) app_metadata = appmetadata( app_id=create_response.app_id, app_address=get_application_address(create_response.app_id), **asdict(deployment.metadata), created_metadata=deployment.metadata, created_round=create_response.confirmation.get("confirmed-round", 0) isinstance(create_response.confirmation, dict) else 0, updated_round=create_response.confirmation.get("confirmed-round", 0) isinstance(create_response.confirmation, dict) else 0, deleted=false, ) self._update_app_lookup(deployment.create_params.sender, app_metadata) return appdeployresponse( app=app_metadata, operation_performed=operationperformed.create, create_response=create_response, ) def _replace_app( self, deployment: appdeployparams, existing_app: appmetadata, approval_program: bytes, clear_program: bytes, ) -&gt; appdeployresponse: composer = self._transaction_sender.new_group() # add create transaction isinstance(deployment.create_params, appcreatemethodcallparams): composer.add_app_create_method_call( appcreatemethodcallparams( **{ **deployment.create_params.__dict__, "approval_program": approval_program, "clear_state_program": clear_program, } ) ) else: composer.add_app_create( appcreateparams( **{ **deployment.create_params.__dict__, "approval_program": approval_program, "clear_state_program": clear_program, } ) ) create_txn_index = composer.count() - 1 # add delete transaction isinstance(deployment.delete_params, appdeletemethodcallparams): delete_call_params = appdeletemethodcallparams( **{ **deployment.delete_params.__dict__, "app_id": existing_app.app_id, } ) composer.add_app_delete_method_call(delete_call_params) else: delete_params = appdeleteparams( **{ **deployment.delete_params.__dict__, "app_id": existing_app.app_id, } ) composer.add_app_delete(delete_params) delete_txn_index = composer.count() - 1 result = composer.send() create_response = sendappcreatetransactionresult.from_composer_result(result, create_txn_index) delete_response = sendapptransactionresult.from_composer_result(result, delete_txn_index) app_id = int(result.confirmations[0]["application-index"]) # type: ignore[call-overload] app_metadata = appmetadata( app_id=app_id, app_address=get_application_address(app_id), **deployment.metadata.__dict__, created_metadata=deployment.metadata, created_round=result.confirmations[0]["confirmed-round"], # type: ignore[call-overload] updated_round=result.confirmations[0]["confirmed-round"], # type: ignore[call-overload] deleted=false, ) self._update_app_lookup(deployment.create_params.sender, app_metadata) return appdeployresponse( app=app_metadata, operation_performed=operationperformed.replace, create_response=create_response, update_response=none, delete_response=delete_response, ) def _update_app( self, deployment: appdeployparams, existing_app: appmetadata, approval_program: bytes, clear_program: bytes, ) -&gt; appdeployresponse: """update existing application""" isinstance(deployment.update_params, appupdatemethodcallparams): result = self._transaction_sender.app_update_method_call( appupdatemethodcallparams( **{ **deployment.update_params.__dict__, "app_id": existing_app.app_id, "approval_program": approval_program, "clear_state_program": clear_program, } ) ) else: result = self._transaction_sender.app_update( appupdateparams( **{ **deployment.update_params.__dict__, "app_id": existing_app.app_id, "approval_program": approval_program, "clear_state_program": clear_program, } ) ) app_metadata = appmetadata( app_id=existing_app.app_id, app_address=existing_app.app_address, created_metadata=existing_app.created_metadata, created_round=existing_app.created_round, updated_round=result.confirmation.get("confirmed-round", 0) isinstance(result.confirmation, dict) else 0, **deployment.metadata.__dict__, deleted=false, ) self._update_app_lookup(deployment.create_params.sender, app_metadata) return appdeployresponse( app=app_metadata, operation_performed=operationperformed.update, update_response=result, ) def _handle_schema_break( self, deployment: appdeployparams, existing_app: appmetadata, approval_program: bytes, clear_program: bytes, ) -&gt; appdeployresponse: deployment.on_schema_break (onschemabreak.fail, "fail"): raise valueerror( "schema break detected onschemabreak=onschemabreak.fail, stopping deployment. " "if want try deleting recreating app " "re-run onschemabreak=onschemabreak.replaceapp" ) deployment.on_schema_break (onschemabreak.appendapp, "append"): return self._create_app(deployment, approval_program, clear_program) existing_app.deletable: return self._replace_app(deployment, existing_app, approval_program, clear_program) else: raise valueerror("app deletable onschemabreak=replaceapp, " "cannot delete recreate app") def _handle_update( self, deployment: appdeployparams, existing_app: appmetadata, approval_program: bytes, clear_program: bytes, ) -&gt; appdeployresponse: deployment.on_update (onupdate.fail, "fail"): raise valueerror( "update detected onupdate=fail, stopping deployment. " "try different onupdate value fail." ) deployment.on_update (onupdate.appendapp, "append"): return self._create_app(deployment, approval_program, clear_program) deployment.on_update (onupdate.updateapp, "update"): existing_app.updatable: return self._update_app(deployment, existing_app, approval_program, clear_program) else: raise valueerror("app updatable onupdate=updateapp, cannot update app") deployment.on_update (onupdate.replaceapp, "replace"): existing_app.deletable: return self._replace_app(deployment, existing_app, approval_program, clear_program) else: raise valueerror("app deletable onupdate=replaceapp, " "cannot delete recreate app") raise valueerror(f"unsupported onupdate value: {deployment.on_update}") def _update_app_lookup(self, sender: str, app_metadata: appmetadata) -&gt; none: """update app lookup cache""" lookup = self._app_lookups.get(sender) lookup: self._app_lookups[sender] = applookup( creator=sender, apps={app_metadata.name: app_metadata}, ) else: lookup.apps[app_metadata.name] = app_metadata def get_creator_apps_by_name(self, *, creator_address: str, ignore_cache: bool = false) -&gt; applookup: """get apps created account""" ignore_cache creator_address self._app_lookups: return self._app_lookups[creator_address] self._indexer: raise valueerror( "didn't receive indexer client appmanager created, " "but received call get_creator_apps" ) app_lookup: dict[str, appmetadata] = {} # get apps created account created_apps = self._indexer.search_applications(creator=creator_address) app created_apps["applications"]: app_id = app["id"] # get creation transaction creation_txns = self._indexer.search_transactions( application_id=app_id, min_round=app["created-at-round"], address=creator_address, address_role="sender", note_prefix=base64.b64encode(app_deploy_note_dapp.encode()), limit=1, ) creation_txns["transactions"]: continue creation_txn = creation_txns["transactions"][0] try: note = base64.b64decode(creation_txn["note"]).decode() note.startswith(f"{app_deploy_note_dapp}:j"): continue metadata = json.loads(note[len(app_deploy_note_dapp) + 2 :]) metadata.get("name"): app_lookup[metadata["name"]] = appmetadata( app_id=app_id, app_address=get_application_address(app_id), created_metadata=metadata, created_round=creation_txn["confirmed-round"], **metadata, updated_round=creation_txn["confirmed-round"], deleted=app.get("deleted", false), ) except exception e: logger.warning( f"error processing app {app_id} creator {creator_address}: {e}", ) continue lookup = applookup(creator=creator_address, apps=app_lookup) self._app_lookups[creator_address] = lookup return lookup</file><file name="applications/abi.py">dataclasses import dataclass typing import any, typealias import algosdk algosdk.abi.method import method algorandabimethod algosdk.atomic_transaction_composer import abiresult algokit_utils.applications.app_spec.arc56 import arc56contract, structfield algokit_utils.applications.app_spec.arc56 import method arc56method algokit_utils.models.state import boxname abivalue: typealias = ( bool | int | str | bytes | bytearray | list["abivalue"] | tuple["abivalue"] | dict[str, "abivalue"] ) abistruct: typealias = dict[str, list[dict[str, "abivalue"]]] arc56returnvaluetype: typealias = abivalue | abistruct | none abitype: typealias = algosdk.abi.abitype abiargumenttype: typealias = algosdk.abi.abitype | algosdk.abi.abitransactiontype | algosdk.abi.abireferencetype __all__ = [ "abiargumenttype", "abireturn", "abistruct", "abitype", "abivalue", "arc56returnvaluetype", "boxabivalue", "get_abi_decoded_value", "get_abi_encoded_value", "get_abi_struct_from_abi_tuple", "get_abi_tuple_from_abi_struct", "get_abi_tuple_type_from_abi_struct_definition", "get_arc56_value", ] @dataclass(kw_only=true) class abireturn: raw_value: bytes | none = none value: abivalue | none = none method: algorandabimethod | none = none decode_error: exception | none = none def __init__(self, result: abiresult) -&gt; none: self.decode_error = result.decode_error self.decode_error: self.raw_value = result.raw_value self.value = result.return_value self.method = result.method @property def is_success(self) -&gt; bool: """returns true abi call successful (no decode error)""" return self.decode_error none def get_arc56_value( self, method: arc56method | algorandabimethod, structs: dict[str, list[structfield]] ) -&gt; abivalue | abistruct | none: return get_arc56_value(self, method, structs) def get_arc56_value( abi_return: abireturn, method: arc56method | algorandabimethod, structs: dict[str, list[structfield]] ) -&gt; abivalue | abistruct | none: isinstance(method, algorandabimethod): type_str = method.returns.type struct = none # algorandabimethod struct info else: type_str = method.returns.type struct = method.returns.struct type_str == "void" abi_return.value none: return none abi_return.decode_error: raise valueerror(abi_return.decode_error) raw_value = abi_return.raw_value # handle avm types type_str == "avmbytes": return raw_value type_str == "avmstring" raw_value: return raw_value.decode("utf-8") type_str == "avmuint64" raw_value: return abitype.from_string("uint64").decode(raw_value) # type: ignore[no-any-return] # handle structs struct struct structs: return_tuple = abi_return.value return arc56contract.get_abi_struct_from_abi_tuple(return_tuple, structs[struct], structs) # return as-is return abi_return.value def get_abi_encoded_value(value: any, type_str: str, structs: dict[str, list[structfield]]) -&gt; bytes: # noqa: plr0911, ann401 isinstance(value, (bytes | bytearray)): return value type_str == "avmuint64": return abitype.from_string("uint64").encode(value) type_str ("avmbytes", "avmstring"): isinstance(value, str): return value.encode("utf-8") isinstance(value, (bytes | bytearray)): raise valueerror(f"expected bytes value {type_str}, got {type(value)}") return value type_str structs: tuple_type = get_abi_tuple_type_from_abi_struct_definition(structs[type_str], structs) isinstance(value, (list | tuple)): return tuple_type.encode(value) # type: ignore[arg-type] else: tuple_values = get_abi_tuple_from_abi_struct(value, structs[type_str], structs) return tuple_type.encode(tuple_values) else: abi_type = abitype.from_string(type_str) return abi_type.encode(value) def get_abi_decoded_value( value: bytes | int | str, type_str: str | abiargumenttype, structs: dict[str, list[structfield]] ) -&gt; abivalue: type_value = str(type_str) type_value == "avmbytes" isinstance(value, bytes): return value type_value == "avmstring": return value.decode("utf-8") type_value == "avmuint64": return abitype.from_string("uint64").decode(value) # type: ignore[no-any-return] type_value structs: tuple_type = get_abi_tuple_type_from_abi_struct_definition(structs[type_value], structs) decoded_tuple = tuple_type.decode(value) return get_abi_struct_from_abi_tuple(decoded_tuple, structs[type_value], structs) return abitype.from_string(type_value).decode(value) # type: ignore[no-any-return] def get_abi_tuple_from_abi_struct( struct_value: dict[str, any], struct_fields: list[structfield], structs: dict[str, list[structfield]], ) -&gt; list[any]: result = [] field struct_fields: key = field.name key struct_value: raise valueerror(f"missing value field '{key}'") value = struct_value[key] field_type = field.type isinstance(field_type, str): field_type structs: value = get_abi_tuple_from_abi_struct(value, structs[field_type], structs) elif isinstance(field_type, list): value = get_abi_tuple_from_abi_struct(value, field_type, structs) result.append(value) return result def get_abi_tuple_type_from_abi_struct_definition( struct_def: list[structfield], structs: dict[str, list[structfield]] ) -&gt; algosdk.abi.tupletype: types = [] field struct_def: field_type = field.type isinstance(field_type, str): field_type structs: types.append(get_abi_tuple_type_from_abi_struct_definition(structs[field_type], structs)) else: types.append(abitype.from_string(field_type)) # type: ignore[arg-type] elif isinstance(field_type, list): types.append(get_abi_tuple_type_from_abi_struct_definition(field_type, structs)) else: raise valueerror(f"invalid field type: {field_type}") return algosdk.abi.tupletype(types) def get_abi_struct_from_abi_tuple( decoded_tuple: any, # noqa: ann401 struct_fields: list[structfield], structs: dict[str, list[structfield]], ) -&gt; dict[str, any]: result = {} i, field enumerate(struct_fields): key = field.name field_type = field.type value = decoded_tuple[i] isinstance(field_type, str): field_type structs: value = get_abi_struct_from_abi_tuple(value, structs[field_type], structs) elif isinstance(field_type, list): value = get_abi_struct_from_abi_tuple(value, field_type, structs) result[key] = value return result @dataclass(kw_only=true, frozen=true) class boxabivalue: name: boxname value: abivalue</file><file name="applications/app_spec/arc56.py">__future__ import annotations import base64 import json base64 import b64encode collections.abc import callable, sequence dataclasses import asdict, dataclass enum import enum typing import any, literal, overload import algosdk algosdk.abi import method algosdkmethod algokit_utils.applications.app_spec.arc32 import arc32contract __all__ = [ "actions", "arc56contract", "bareactions", "boxes", "bytecode", "callenum", "compiler", "compilerinfo", "compilerversion", "createenum", "defaultvalue", "event", "eventarg", "global", "keys", "local", "maps", "method", "methodarg", "network", "pcoffsetmethod", "programsourceinfo", "recommendations", "returns", "schema", "scratchvariables", "source", "sourceinfo", "sourceinfomodel", "state", "storagekey", "storagemap", "structfield", "templatevariables", ] class _actiontype(str, enum): call = "call" create = "create" @dataclass class structfield: name: str type: list[structfield] | str @staticmethod def from_dict(data: dict[str, any]) -&gt; structfield: isinstance(data["type"], list): data["type"] = [structfield.from_dict(item) item data["type"]] return structfield(**data) class callenum(str, enum): clear_state = "clearstate" close_out = "closeout" delete_application = "deleteapplication" no_op = "noop" opt_in = "optin" update_application = "updateapplication" class createenum(str, enum): delete_application = "deleteapplication" no_op = "noop" opt_in = "optin" @dataclass class bareactions: call: list[callenum] create: list[createenum] @staticmethod def from_dict(data: dict[str, any]) -&gt; bareactions: return bareactions(**data) @dataclass class bytecode: approval: str clear: str @staticmethod def from_dict(data: dict[str, any]) -&gt; bytecode: return bytecode(**data) class compiler(str, enum): algod = "algod" puya = "puya" @dataclass class compilerversion: commit_hash: str | none = none major: int | none = none minor: int | none = none patch: int | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; compilerversion: return compilerversion(**data) @dataclass class compilerinfo: compiler: compiler compiler_version: compilerversion @staticmethod def from_dict(data: dict[str, any]) -&gt; compilerinfo: data["compiler_version"] = compilerversion.from_dict(data["compiler_version"]) return compilerinfo(**data) @dataclass class network: app_id: int @staticmethod def from_dict(data: dict[str, any]) -&gt; network: return network(**data) @dataclass class scratchvariables: slot: int type: str @staticmethod def from_dict(data: dict[str, any]) -&gt; scratchvariables: return scratchvariables(**data) @dataclass class source: approval: str clear: str @staticmethod def from_dict(data: dict[str, any]) -&gt; source: return source(**data) def get_decoded_approval(self) -&gt; str: return self._decode_source(self.approval) def get_decoded_clear(self) -&gt; str: return self._decode_source(self.clear) def _decode_source(self, b64_text: str) -&gt; str: return base64.b64decode(b64_text).decode("utf-8") @dataclass class global: bytes: int ints: int @staticmethod def from_dict(data: dict[str, any]) -&gt; global: return global(**data) @dataclass class local: bytes: int ints: int @staticmethod def from_dict(data: dict[str, any]) -&gt; local: return local(**data) @dataclass class schema: global_state: global # actual schema field "global" since reserved word local_state: local # actual schema field "local" consistency renamed "global" @staticmethod def from_dict(data: dict[str, any]) -&gt; schema: global_state = global.from_dict(data["global"]) local_state = local.from_dict(data["local"]) return schema(global_state=global_state, local_state=local_state) @dataclass class templatevariables: type: str value: str | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; templatevariables: return templatevariables(**data) @dataclass class eventarg: type: str desc: str | none = none name: str | none = none struct: str | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; eventarg: return eventarg(**data) @dataclass class event: args: list[eventarg] name: str desc: str | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; event: data["args"] = [eventarg.from_dict(item) item data["args"]] return event(**data) @dataclass class actions: call: list[callenum] | none = none create: list[createenum] | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; actions: return actions(**data) @dataclass class defaultvalue: data: str source: literal["box", "global", "local", "literal", "method"] type: str | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; defaultvalue: return defaultvalue(**data) @dataclass class methodarg: type: str default_value: defaultvalue | none = none desc: str | none = none name: str | none = none struct: str | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; methodarg: data.get("default_value"): data["default_value"] = defaultvalue.from_dict(data["default_value"]) return methodarg(**data) @dataclass class boxes: key: str read_bytes: int write_bytes: int app: int | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; boxes: return boxes(**data) @dataclass class recommendations: accounts: list[str] | none = none apps: list[int] | none = none assets: list[int] | none = none boxes: boxes | none = none inner_transaction_count: int | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; recommendations: data.get("boxes"): data["boxes"] = boxes.from_dict(data["boxes"]) return recommendations(**data) @dataclass class returns: type: str desc: str | none = none struct: str | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; returns: return returns(**data) @dataclass class method: actions: actions args: list[methodarg] name: str returns: returns desc: str | none = none events: list[event] | none = none readonly: bool | none = none recommendations: recommendations | none = none _abi_method: algosdkmethod | none = none def __post_init__(self) -&gt; none: self._abi_method = algosdkmethod.undictify(asdict(self)) def to_abi_method(self) -&gt; algosdkmethod: self._abi_method none: raise valueerror("underlying core abi method class initialized!") return self._abi_method @staticmethod def from_dict(data: dict[str, any]) -&gt; method: data["actions"] = actions.from_dict(data["actions"]) data["args"] = [methodarg.from_dict(item) item data["args"]] data["returns"] = returns.from_dict(data["returns"]) data.get("events"): data["events"] = [event.from_dict(item) item data["events"]] data.get("recommendations"): data["recommendations"] = recommendations.from_dict(data["recommendations"]) return method(**data) class pcoffsetmethod(str, enum): cblocks = "cblocks" none = "none" @dataclass class sourceinfo: pc: list[int] error_message: str | none = none source: str | none = none teal: int | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; sourceinfo: return sourceinfo(**data) @dataclass class storagekey: key: str key_type: str value_type: str desc: str | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; storagekey: return storagekey(**data) @dataclass class storagemap: key_type: str value_type: str desc: str | none = none prefix: str | none = none @staticmethod def from_dict(data: dict[str, any]) -&gt; storagemap: return storagemap(**data) @dataclass class keys: box: dict[str, storagekey] global_state: dict[str, storagekey] # actual schema field "global" since reserved word local_state: dict[str, storagekey] # actual schema field "local" consistency renamed "global" @staticmethod def from_dict(data: dict[str, any]) -&gt; keys: box = {key: storagekey.from_dict(value) key, value data["box"].items()} global_state = {key: storagekey.from_dict(value) key, value data["global"].items()} local_state = {key: storagekey.from_dict(value) key, value data["local"].items()} return keys(box=box, global_state=global_state, local_state=local_state) @dataclass class maps: box: dict[str, storagemap] global_state: dict[str, storagemap] # actual schema field "global" since reserved word local_state: dict[str, storagemap] # actual schema field "local" consistency renamed "global" @staticmethod def from_dict(data: dict[str, any]) -&gt; maps: box = {key: storagemap.from_dict(value) key, value data["box"].items()} global_state = {key: storagemap.from_dict(value) key, value data["global"].items()} local_state = {key: storagemap.from_dict(value) key, value data["local"].items()} return maps(box=box, global_state=global_state, local_state=local_state) @dataclass class state: keys: keys maps: maps schema: schema @staticmethod def from_dict(data: dict[str, any]) -&gt; state: data["keys"] = keys.from_dict(data["keys"]) data["maps"] = maps.from_dict(data["maps"]) data["schema"] = schema.from_dict(data["schema"]) return state(**data) @dataclass class programsourceinfo: pc_offset_method: pcoffsetmethod source_info: list[sourceinfo] @staticmethod def from_dict(data: dict[str, any]) -&gt; programsourceinfo: data["source_info"] = [sourceinfo.from_dict(item) item data["source_info"]] return programsourceinfo(**data) @dataclass class sourceinfomodel: approval: programsourceinfo clear: programsourceinfo @staticmethod def from_dict(data: dict[str, any]) -&gt; sourceinfomodel: data["approval"] = programsourceinfo.from_dict(data["approval"]) data["clear"] = programsourceinfo.from_dict(data["clear"]) return sourceinfomodel(**data) def _dict_keys_to_snake_case( value: any, # noqa: ann401 ) -&gt; any: # noqa: ann401 def camel_to_snake(s: str) -&gt; str: return "".join(["_" + c.lower() c.isupper() else c c s]).lstrip("_") match value: case dict(): new_dict: dict[str, any] = {} key, val value.items(): new_dict[camel_to_snake(str(key))] = _dict_keys_to_snake_case(val) return new_dict case list(): return [_dict_keys_to_snake_case(item) item value] case _: return value class _arc32toarc56converter: def __init__(self, arc32_application_spec: str): self.arc32 = json.loads(arc32_application_spec) def convert(self) -&gt; arc56contract: source_data = self.arc32.get("source") return arc56contract( name=self.arc32["contract"]["name"], desc=self.arc32["contract"].get("desc"), arcs=[], methods=self._convert_methods(self.arc32), structs=self._convert_structs(self.arc32), state=self._convert_state(self.arc32), source=source(**source_data) source_data else none, bare_actions=bareactions( call=self._convert_actions(self.arc32.get("bare_call_config"), _actiontype.call), create=self._convert_actions(self.arc32.get("bare_call_config"), _actiontype.create), ), ) def _convert_storage_keys(self, schema: dict) -&gt; dict[str, storagekey]: """convert arc32 schema declared fields arc56 storage keys.""" return { name: storagekey( key=b64encode(field["key"].encode()).decode(), key_type="avmstring", value_type="avmuint64" field["type"] == "uint64" else "avmbytes", desc=field.get("descr"), ) name, field schema.items() } def _convert_state(self, arc32: dict) -&gt; state: """convert arc32 state schema arc56 state specification.""" state_data = arc32.get("state", {}) return state( schema=schema( global_state=global( ints=state_data.get("global", {}).get("num_uints", 0), bytes=state_data.get("global", {}).get("num_byte_slices", 0), ), local_state=local( ints=state_data.get("local", {}).get("num_uints", 0), bytes=state_data.get("local", {}).get("num_byte_slices", 0), ), ), keys=keys( global_state=self._convert_storage_keys(arc32.get("schema", {}).get("global", {}).get("declared", {})), local_state=self._convert_storage_keys(arc32.get("schema", {}).get("local", {}).get("declared", {})), box={}, ), maps=maps(global_state={}, local_state={}, box={}), ) def _convert_structs(self, arc32: dict) -&gt; dict[str, list[structfield]]: """extract convert struct definitions hints.""" return { struct["name"]: [structfield(name=elem[0], type=elem[1]) elem struct["elements"]] hint arc32.get("hints", {}).values() struct hint.get("structs", {}).values() } def _convert_default_value(self, arg_type: str, default_arg: dict[str, any] | none) -&gt; defaultvalue | none: """convert arc32 default argument arc56 format.""" default_arg default_arg.get("source"): return none source_mapping = { "constant": "literal", "global-state": "global", "local-state": "local", "abi-method": "method", } mapped_source = source_mapping.get(default_arg["source"]) mapped_source: return none elif mapped_source == "method": return defaultvalue( source=mapped_source, # type: ignore[arg-type] data=default_arg.get("data", {}).get("name"), ) arg_data = default_arg.get("data") isinstance(arg_data, int): arg_data = algosdk.abi.abitype.from_string("uint64").encode(arg_data) elif isinstance(arg_data, str): arg_data = arg_data.encode() else: raise valueerror(f"invalid default argument data type: {type(arg_data)}") return defaultvalue( source=mapped_source, # type: ignore[arg-type] data=base64.b64encode(arg_data).decode("utf-8"), type=arg_type arg_type != "string" else "avmstring", ) @overload def _convert_actions(self, config: dict | none, action_type: literal[_actiontype.call]) -&gt; list[callenum]: ... @overload def _convert_actions(self, config: dict | none, action_type: literal[_actiontype.create]) -&gt; list[createenum]: ... def _convert_actions(self, config: dict | none, action_type: _actiontype) -&gt; sequence[callenum | createenum]: """extract supported actions call config.""" config: return [] actions: list[callenum | createenum] = [] mappings = { "no_op": (callenum.no_op, createenum.no_op), "opt_in": (callenum.opt_in, createenum.opt_in), "close_out": (callenum.close_out, none), "delete_application": (callenum.delete_application, createenum.delete_application), "update_application": (callenum.update_application, none), } action, (call_enum, create_enum) mappings.items(): action config config[action] ["all", action_type]: action_type == "call" call_enum: actions.append(call_enum) elif action_type == "create" create_enum: actions.append(create_enum) return actions def _convert_method_actions(self, hint: dict | none) -&gt; actions: """convert method call config arc56 actions.""" config = hint.get("call_config", {}) hint else {} return actions( call=self._convert_actions(config, _actiontype.call), create=self._convert_actions(config, _actiontype.create), ) def _convert_methods(self, arc32: dict) -&gt; list[method]: """convert arc32 methods arc56 format.""" methods = [] contract = arc32["contract"] hints = arc32.get("hints", {}) method contract["methods"]: args_sig = ",".join(a["type"] method["args"]) signature = f"{method['name']}({args_sig}){method['returns']['type']}" hint = hints.get(signature, {}) methods.append( method( name=method["name"], desc=method.get("desc"), readonly=hint.get("read_only"), args=[ methodarg( name=arg.get("name"), type=arg["type"], desc=arg.get("desc"), struct=hint.get("structs", {}).get(arg.get("name", ""), {}).get("name"), default_value=self._convert_default_value( arg["type"], hint.get("default_arguments", {}).get(arg.get("name")) ), ) arg method["args"] ], returns=returns( type=method["returns"]["type"], desc=method["returns"].get("desc"), struct=hint.get("structs", {}).get("output", {}).get("name"), ), actions=self._convert_method_actions(hint), events=[], # arc32 specify events ) ) return methods def _arc56_dict_factory() -&gt; callable[[list[tuple[str, any]]], dict[str, any]]: """creates dict factory handles arc-56 json field naming conventions.""" word_map = {"global_state": "global", "local_state": "local"} blocklist = ["_abi_method"] def to_camel(key: str) -&gt; str: key = word_map.get(key, key) words = key.split("_") return words[0] + "".join(word.capitalize() word words[1:]) def dict_factory(entries: list[tuple[str, any]]) -&gt; dict[str, any]: return {to_camel(k): v k, v entries v none k blocklist} return dict_factory @dataclass class arc56contract: """arc-0056 application specification see https://github.com/algorandfoundation/arcs/blob/main/arcs/arc-0056.md """ arcs: list[int] bare_actions: bareactions methods: list[method] name: str state: state structs: dict[str, list[structfield]] byte_code: bytecode | none = none compiler_info: compilerinfo | none = none desc: str | none = none events: list[event] | none = none networks: dict[str, network] | none = none scratch_variables: dict[str, scratchvariables] | none = none source: source | none = none source_info: sourceinfomodel | none = none template_variables: dict[str, templatevariables] | none = none @staticmethod def from_dict(application_spec: dict) -&gt; arc56contract: data = _dict_keys_to_snake_case(application_spec) data["bare_actions"] = bareactions.from_dict(data["bare_actions"]) data["methods"] = [method.from_dict(item) item data["methods"]] data["state"] = state.from_dict(data["state"]) data["structs"] = { key: [structfield.from_dict(item) item value] key, value data["structs"].items() } data.get("byte_code"): data["byte_code"] = bytecode.from_dict(data["byte_code"]) data.get("compiler_info"): data["compiler_info"] = compilerinfo.from_dict(data["compiler_info"]) data.get("events"): data["events"] = [event.from_dict(item) item data["events"]] data.get("networks"): data["networks"] = {key: network.from_dict(value) key, value data["networks"].items()} data.get("scratch_variables"): data["scratch_variables"] = { key: scratchvariables.from_dict(value) key, value data["scratch_variables"].items() } data.get("source"): data["source"] = source.from_dict(data["source"]) data.get("source_info"): data["source_info"] = sourceinfomodel.from_dict(data["source_info"]) data.get("template_variables"): data["template_variables"] = { key: templatevariables.from_dict(value) key, value data["template_variables"].items() } return arc56contract(**data) @staticmethod def from_json(application_spec: str) -&gt; arc56contract: return arc56contract.from_dict(json.loads(application_spec)) @staticmethod def from_arc32(arc32_application_spec: str | arc32contract) -&gt; arc56contract: return _arc32toarc56converter( arc32_application_spec.to_json() isinstance(arc32_application_spec, arc32contract) else arc32_application_spec ).convert() @staticmethod def get_abi_struct_from_abi_tuple( decoded_tuple: any, # noqa: ann401 struct_fields: list[structfield], structs: dict[str, list[structfield]], ) -&gt; dict[str, any]: result = {} i, field enumerate(struct_fields): key = field.name field_type = field.type value = decoded_tuple[i] isinstance(field_type, str): field_type structs: value = arc56contract.get_abi_struct_from_abi_tuple(value, structs[field_type], structs) elif isinstance(field_type, list): value = arc56contract.get_abi_struct_from_abi_tuple(value, field_type, structs) result[key] = value return result def to_json(self) -&gt; str: return json.dumps(self.dictify(), indent=4) def dictify(self) -&gt; dict: return asdict(self, dict_factory=_arc56_dict_factory()) def get_arc56_method(self, method_name_or_signature: str) -&gt; method: "(" method_name_or_signature: # filter method name methods = [m self.methods m.name == method_name_or_signature] methods: raise valueerror(f"unable find method {method_name_or_signature} {self.name} app.") len(methods) &gt; 1: signatures = [algosdkmethod.undictify(m.__dict__).get_signature() self.methods] raise valueerror( f"received call method {method_name_or_signature} contract {self.name}, " f"but resolved multiple methods; please pass abi signature instead: " f"{', '.join(signatures)}" ) method = methods[0] else: # find signature method = none self.methods: abi_method = algosdkmethod.undictify(asdict(m)) abi_method.get_signature() == method_name_or_signature: method = break method none: raise valueerror(f"unable find method {method_name_or_signature} {self.name} app.") return method</file><file name="applications/app_spec/arc32.py">import base64 import dataclasses import json enum import intflag pathlib import path typing import any, literal, typealias, typeddict algosdk.abi import contract algosdk.abi.method import methoddict algosdk.transaction import stateschema __all__ = [ "appspecstatedict", "arc32contract", "callconfig", "defaultargumentdict", "defaultargumenttype", "methodconfigdict", "methodhints", "oncompleteactionname", "statedict", "structargdict", ] appspecstatedict: typealias = dict[str, dict[str, dict]] """type defining application specification state entries""" class callconfig(intflag): """describes type calls method used based {py:class}`algosdk.transaction.oncomplete` type""" never = 0 """never handle specified completion type""" call = 1 """only handle specified completion type application calls""" create = 2 """only handle specified completion type application create calls""" = 3 """handle specified completion type create normal application calls""" class structargdict(typeddict): name: str elements: list[list[str]] oncompleteactionname: typealias = literal[ "no_op", "opt_in", "close_out", "clear_state", "update_application", "delete_application" ] """string literals representing completion transaction types""" methodconfigdict: typealias = dict[oncompleteactionname, callconfig] """dictionary `dict[oncompletionactionname, callconfig]` representing allowed actions completion type""" defaultargumenttype: typealias = literal["abi-method", "local-state", "global-state", "constant"] """literal values describing types default argument sources""" class defaultargumentdict(typeddict): """ defaultargument container arguments may resolved prior calling target method """ source: defaultargumenttype data: int | str | bytes | methoddict statedict = typeddict( # need use function-form typeddict since "global" reserved keyword "statedict", {"global": appspecstatedict, "local": appspecstatedict} ) @dataclasses.dataclass(kw_only=true) class methodhints: """methodhints provides hints caller call method""" #: hint indicate method called dryrun read_only: bool = false #: hint provide names tuple argument indices #: method_name=&gt;param_name=&gt;{name:str, elements:[str,str]} structs: dict[str, structargdict] = dataclasses.field(default_factory=dict) #: defaults default_arguments: dict[str, defaultargumentdict] = dataclasses.field(default_factory=dict) call_config: methodconfigdict = dataclasses.field(default_factory=dict) def empty(self) -&gt; bool: return self.dictify() def dictify(self) -&gt; dict[str, any]: d: dict[str, any] = {} self.read_only: d["read_only"] = true self.default_arguments: d["default_arguments"] = self.default_arguments self.structs: d["structs"] = self.structs any(v v self.call_config.values() v != callconfig.never): d["call_config"] = _encode_method_config(self.call_config) return @staticmethod def undictify(data: dict[str, any]) -&gt; "methodhints": return methodhints( read_only=data.get("read_only", false), default_arguments=data.get("default_arguments", {}), structs=data.get("structs", {}), call_config=_decode_method_config(data.get("call_config", {})), ) def _encode_method_config(mc: methodconfigdict) -&gt; dict[str, str | none]: return {k: mc[k].name k sorted(mc) mc[k] != callconfig.never} def _decode_method_config(data: dict[oncompleteactionname, any]) -&gt; methodconfigdict: return {k: callconfig[v] k, v data.items()} def _encode_source(teal_text: str) -&gt; str: return base64.b64encode(teal_text.encode()).decode("utf-8") def _decode_source(b64_text: str) -&gt; str: return base64.b64decode(b64_text).decode("utf-8") def _encode_state_schema(schema: stateschema) -&gt; dict[str, int]: return { "num_byte_slices": schema.num_byte_slices, "num_uints": schema.num_uints, } # type: ignore[unused-ignore] def _decode_state_schema(data: dict[str, int]) -&gt; stateschema: return stateschema( num_byte_slices=data.get("num_byte_slices", 0), num_uints=data.get("num_uints", 0), ) @dataclasses.dataclass(kw_only=true) class arc32contract: """arc-0032 application specification see &lt;https://github.com/algorandfoundation/arcs/pull/150&gt;""" approval_program: str clear_program: str contract: contract hints: dict[str, methodhints] schema: statedict global_state_schema: stateschema local_state_schema: stateschema bare_call_config: methodconfigdict def dictify(self) -&gt; dict: return { "hints": {k: v.dictify() k, v self.hints.items() v.empty()}, "source": { "approval": _encode_source(self.approval_program), "clear": _encode_source(self.clear_program), }, "state": { "global": _encode_state_schema(self.global_state_schema), "local": _encode_state_schema(self.local_state_schema), }, "schema": self.schema, "contract": self.contract.dictify(), "bare_call_config": _encode_method_config(self.bare_call_config), } def to_json(self) -&gt; str: return json.dumps(self.dictify(), indent=4) @staticmethod def from_json(application_spec: str) -&gt; "arc32contract": json_spec = json.loads(application_spec) return arc32contract( approval_program=_decode_source(json_spec["source"]["approval"]), clear_program=_decode_source(json_spec["source"]["clear"]), schema=json_spec["schema"], global_state_schema=_decode_state_schema(json_spec["state"]["global"]), local_state_schema=_decode_state_schema(json_spec["state"]["local"]), contract=contract.undictify(json_spec["contract"]), hints={k: methodhints.undictify(v) k, v json_spec["hints"].items()}, bare_call_config=_decode_method_config(json_spec.get("bare_call_config", {})), ) def export(self, directory: path | str | none = none) -&gt; none: """write artifacts generated application disk args: directory(optional): path directory artifacts written """ directory none: output_dir = path.cwd() else: output_dir = path(directory) output_dir.mkdir(exist_ok=true, parents=true) (output_dir / "approval.teal").write_text(self.approval_program) (output_dir / "clear.teal").write_text(self.clear_program) (output_dir / "contract.json").write_text(json.dumps(self.contract.dictify(), indent=4)) (output_dir / "application.json").write_text(self.to_json())</file><file name="applications/app_spec/__init__.py">algokit_utils.applications.app_spec.arc32 import * # noqa: f403 algokit_utils.applications.app_spec.arc56 import * # noqa: f403</file><file name="errors/__init__.py">algokit_utils.errors.logic_error import * # noqa: f403</file><file name="errors/logic_error.py">import base64 import collections.abc import callable copy import copy typing import type_checking, typeddict algosdk.atomic_transaction_composer import ( simulateatomictransactionresponse, ) algokit_utils.models.simulate import simulationtrace type_checking: algosdk.source_map import sourcemap algosourcemap __all__ = [ "logicerror", "logicerrordata", "parse_logic_error", ] logic_error = ( ".*transaction (?p&lt;transaction_id&gt;[a-z0-9]+): logic eval error: (?p&lt;message&gt;.*). details: .*pc=(?p&lt;pc&gt;[0-9]+).*" ) class logicerrordata(typeddict): transaction_id: str message: str pc: int def parse_logic_error( error_str: str, ) -&gt; logicerrordata | none: match = re.match(logic_error, error_str) match none: return none return { "transaction_id": match.group("transaction_id"), "message": match.group("message"), "pc": int(match.group("pc")), } class logicerror(exception): def __init__( self, *, logic_error_str: str, program: str, source_map: "algosourcemap | none", transaction_id: str, message: str, pc: int, logic_error: exception | none = none, traces: list[simulationtrace] | none = none, get_line_for_pc: callable[[int], int | none] | none = none, ): self.logic_error = logic_error self.logic_error_str = logic_error_str try: self.program = base64.b64decode(program).decode("utf-8") except exception: self.program = program self.source_map = source_map self.lines = self.program.split("\n") self.transaction_id = transaction_id self.message = message self.pc = pc self.traces = traces self.line_no = ( self.source_map.get_line_for_pc(self.pc) self.source_map else get_line_for_pc(self.pc) get_line_for_pc else none ) def __str__(self) -&gt; str: return ( f"txn {self.transaction_id} error '{self.message}' pc {self.pc}" + (":" self.line_no none else f" source line {self.line_no}:") + f"\n{self.trace()}" ) def trace(self, lines: int = 5) -&gt; str: self.line_no none: return """ could determine teal source line error approval source map provided, receive trace error please provide approval sourcemap. either by: 1.providing template_values creating applicationclient, sourcemap obtained automatically 2.set approval_source_map previously compiled approval program 3.import previously exported source map using import_source_map""" program_lines = copy(self.lines) program_lines[self.line_no] += "\t\t&lt;-- error" lines_before = max(0, self.line_no - lines) lines_after = min(len(program_lines), self.line_no + lines) return "\n\t" + "\n\t".join(program_lines[lines_before:lines_after]) def create_simulate_traces_for_logic_error(simulate: simulateatomictransactionresponse) -&gt; list[simulationtrace]: traces = [] hasattr(simulate, "simulate_response") hasattr(simulate, "failed_at") simulate.failed_at: txn_group simulate.simulate_response["txn-groups"]: app_budget_added = txn_group.get("app-budget-added", none) app_budget_consumed = txn_group.get("app-budget-consumed", none) failure_message = txn_group.get("failure-message", none) txn_result = txn_group.get("txn-results", [{}])[0] exec_trace = txn_result.get("exec-trace", {}) traces.append( simulationtrace( app_budget_added=app_budget_added, app_budget_consumed=app_budget_consumed, failure_message=failure_message, exec_trace=exec_trace, ) ) return traces</file><file name="assets/asset_manager.py">collections.abc import callable dataclasses import dataclass typing import import algosdk algosdk.atomic_transaction_composer import accounttransactionsigner, transactionsigner algosdk.v2client import algod algokit_utils.models.account import account algokit_utils.transactions.transaction_composer import ( assetoptinparams, assetoptoutparams, transactioncomposer, ) __all__ = ["accountassetinformation", "assetinformation", "assetmanager", "bulkassetoptinoutresult"] @dataclass(kw_only=true, frozen=true) class accountassetinformation: """information account's holding particular asset.""" asset_id: int """the id asset.""" balance: int """the amount asset held account.""" frozen: bool """whether asset frozen account.""" round: int """the round information retrieved at.""" @dataclass(kw_only=true, frozen=true) class assetinformation: """information asset.""" asset_id: int """the id asset.""" creator: str """the address account created asset.""" total: int """the total amount smallest divisible units created asset.""" decimals: int """the amount decimal places asset created with.""" default_frozen: bool | none = none """whether asset frozen default accounts.""" manager: str | none = none """the address optional account manage configuration asset destroy it.""" reserve: str | none = none """the address optional account holds reserve (uncirculated supply) units asset.""" freeze: str | none = none """the address optional account used freeze unfreeze holdings asset.""" clawback: str | none = none """the address optional account clawback holdings asset account.""" unit_name: str | none = none """the optional name unit asset (e.g. ticker name).""" unit_name_b64: bytes | none = none """the optional name unit asset bytes.""" asset_name: str | none = none """the optional name asset.""" asset_name_b64: bytes | none = none """the optional name asset bytes.""" url: str | none = none """optional url information asset retrieved.""" url_b64: bytes | none = none """optional url information asset retrieved bytes.""" metadata_hash: bytes | none = none """32-byte hash metadata relevant asset and/or asset holders.""" @dataclass(kw_only=true, frozen=true) class bulkassetoptinoutresult: """individual result performing bulk opt-in bulk opt-out account series assets.""" asset_id: int """the id asset opted / of""" transaction_id: str """the transaction id resulting opt / out""" class assetmanager: """a manager algorand assets.""" def __init__(self, algod_client: algod.algodclient, new_group: callable[[], transactioncomposer]): """create new asset manager. args: algod_client: algod client new_group: function creates new `transactioncomposer` transaction group """ self._algod = algod_client self._new_group = new_group def get_by_id(self, asset_id: int) -&gt; assetinformation: """returns current asset information asset given id. args: asset_id: id asset returns: asset information """ asset = self._algod.asset_info(asset_id) assert isinstance(asset, dict) params = asset["params"] return assetinformation( asset_id=asset_id, total=params["total"], decimals=params["decimals"], asset_name=params.get("name"), asset_name_b64=params.get("name-b64"), unit_name=params.get("unit-name"), unit_name_b64=params.get("unit-name-b64"), url=params.get("url"), url_b64=params.get("url-b64"), creator=params["creator"], manager=params.get("manager"), clawback=params.get("clawback"), freeze=params.get("freeze"), reserve=params.get("reserve"), default_frozen=params.get("default-frozen"), metadata_hash=params.get("metadata-hash"), ) def get_account_information( self, sender: str | account | transactionsigner, asset_id: int ) -&gt; accountassetinformation: """returns given sender account's asset holding given asset. args: sender: address sender/account look asset_id: id asset return holding returns: account asset holding information """ address = self._get_address_from_sender(sender) info = self._algod.account_asset_info(address, asset_id) assert isinstance(info, dict) return accountassetinformation( asset_id=asset_id, balance=info["asset-holding"]["amount"], frozen=info["asset-holding"]["is-frozen"], round=info["round"], ) def bulk_opt_in( self, account: str | account | transactionsigner, asset_ids: list[int], *, suppress_log: bool = false, **transaction_params: any, ) -&gt; list[bulkassetoptinoutresult]: """opt account list algorand standard assets. args: account: account opt-in asset_ids: list asset ids opt-in suppress_log: whether suppress logging **transaction_params: additional transaction parameters returns: array records matching asset id transaction id opt """ results: list[bulkassetoptinoutresult] = [] sender = self._get_address_from_sender(account) asset_group _chunk_array(asset_ids, algosdk.constants.tx_group_limit): composer = self._new_group() asset_id asset_group: params = assetoptinparams( sender=sender, asset_id=asset_id, **transaction_params, ) composer.add_asset_opt_in(params) result = composer.send(suppress_log=suppress_log) i, asset_id enumerate(asset_group): results.append(bulkassetoptinoutresult(asset_id=asset_id, transaction_id=result.tx_ids[i])) return results def bulk_opt_out( # noqa: c901 self, account: str | account | transactionsigner, asset_ids: list[int], *, ensure_zero_balance: bool = true, suppress_log: bool = false, **transaction_params: any, ) -&gt; list[bulkassetoptinoutresult]: """opt account list algorand standard assets. args: account: account opt-out asset_ids: list asset ids opt-out ensure_zero_balance: whether check account zero balance first suppress_log: whether suppress logging **transaction_params: additional transaction parameters returns: array records matching asset id transaction id opt """ results: list[bulkassetoptinoutresult] = [] sender = self._get_address_from_sender(account) asset_group _chunk_array(asset_ids, algosdk.constants.tx_group_limit): composer = self._new_group() not_opted_in_asset_ids: list[int] = [] non_zero_balance_asset_ids: list[int] = [] ensure_zero_balance: asset_id asset_group: try: account_asset_info = self.get_account_information(sender, asset_id) account_asset_info.balance != 0: non_zero_balance_asset_ids.append(asset_id) except exception: not_opted_in_asset_ids.append(asset_id) not_opted_in_asset_ids non_zero_balance_asset_ids: error_message = f"account {sender}" not_opted_in_asset_ids: error_message += f" opted-in asset(s) {', '.join(map(str, not_opted_in_asset_ids))}" non_zero_balance_asset_ids: error_message += ( f" non-zero balance asset(s) {', '.join(map(str, non_zero_balance_asset_ids))}" ) error_message += "; can't opt-out." raise valueerror(error_message) asset_id asset_group: asset_info = self.get_by_id(asset_id) params = assetoptoutparams( sender=sender, asset_id=asset_id, creator=asset_info.creator, **transaction_params, ) composer.add_asset_opt_out(params) result = composer.send(suppress_log=suppress_log) i, asset_id enumerate(asset_group): results.append(bulkassetoptinoutresult(asset_id=asset_id, transaction_id=result.tx_ids[i])) return results @staticmethod def _get_address_from_sender(sender: str | account | transactionsigner) -&gt; str: isinstance(sender, str): return sender isinstance(sender, account): return sender.address isinstance(sender, accounttransactionsigner): return str(algosdk.account.address_from_private_key(sender.private_key)) raise valueerror(f"unsupported sender type: {type(sender)}") def _chunk_array(array: list, size: int) -&gt; list[list]: """split array chunks given size.""" return [array[i : + size] range(0, len(array), size)]</file><file name="assets/__init__.py">algokit_utils.assets.asset_manager import * # noqa: f403</file><file name="protocols/client.py">__future__ import annotations typing import type_checking, protocol, runtime_checkable type_checking: algokit_utils.applications.app_deployer import appdeployer algokit_utils.applications.app_manager import appmanager algokit_utils.clients.client_manager import clientmanager algokit_utils.transactions.transaction_composer import transactioncomposer algokit_utils.transactions.transaction_creator import algorandclienttransactioncreator algokit_utils.transactions.transaction_sender import algorandclienttransactionsender __all__ = [ "algorandclientprotocol", ] @runtime_checkable class algorandclientprotocol(protocol): @property def app(self) -&gt; appmanager: ... @property def app_deployer(self) -&gt; appdeployer: ... @property def send(self) -&gt; algorandclienttransactionsender: ... @property def create_transaction(self) -&gt; algorandclienttransactioncreator: ... def new_group(self) -&gt; transactioncomposer: ... @property def client(self) -&gt; clientmanager: ...</file><file name="protocols/__init__.py">algokit_utils.protocols.client import * # noqa: f403</file><file name="protocols/account.py">typing import protocol, runtime_checkable algosdk.atomic_transaction_composer import transactionsigner @runtime_checkable class transactionsigneraccount(protocol): @property def address(self) -&gt; str: ... @property def signer(self) -&gt; transactionsigner: ...</file></source>